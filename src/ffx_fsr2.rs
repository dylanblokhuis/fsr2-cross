/* automatically generated by rust-bindgen 0.70.1 */

pub const FFX_MAX_NUM_SRVS: u32 = 16;
pub const FFX_MAX_NUM_UAVS: u32 = 8;
pub const FFX_MAX_NUM_CONST_BUFFERS: u32 = 2;
pub const FFX_MAX_CONST_SIZE: u32 = 64;
pub const FFX_UNSPECIFIED_VERSION: u32 = 4294946048;
pub const FFX_MAXIMUM_PATH: u32 = 260;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_NULL: u32 = 0;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_OPAQUE_ONLY: u32 = 1;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_COLOR: u32 = 2;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_MOTION_VECTORS: u32 = 3;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_DEPTH: u32 = 4;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_EXPOSURE: u32 = 5;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_REACTIVE_MASK: u32 = 6;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_TRANSPARENCY_AND_COMPOSITION_MASK: u32 = 7;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_RECONSTRUCTED_PREVIOUS_NEAREST_DEPTH: u32 = 8;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS: u32 = 9;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_DEPTH: u32 = 10;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR: u32 = 11;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_LOCK_STATUS: u32 = 12;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_NEW_LOCKS: u32 = 13;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_PREPARED_INPUT_COLOR: u32 = 14;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_LUMA_HISTORY: u32 = 15;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_DEBUG_OUTPUT: u32 = 16;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_LANCZOS_LUT: u32 = 17;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_SPD_ATOMIC_COUNT: u32 = 18;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_UPSCALED_OUTPUT: u32 = 19;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_RCAS_INPUT: u32 = 20;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_LOCK_STATUS_1: u32 = 21;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_LOCK_STATUS_2: u32 = 22;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR_1: u32 = 23;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR_2: u32 = 24;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_DEFAULT_REACTIVITY: u32 = 25;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_DEFAULT_TRANSPARENCY_AND_COMPOSITION: u32 = 26;
pub const FFX_FSR2_RESOURCE_IDENTITIER_UPSAMPLE_MAXIMUM_BIAS_LUT: u32 = 27;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_REACTIVE_MASKS: u32 = 28;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE: u32 = 29;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_0: u32 = 29;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_1: u32 = 30;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_2: u32 = 31;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_3: u32 = 32;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_4: u32 = 33;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_5: u32 = 34;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_6: u32 = 35;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_7: u32 = 36;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_8: u32 = 37;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_9: u32 = 38;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_10: u32 = 39;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_11: u32 = 40;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_12: u32 = 41;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_DEFAULT_EXPOSURE: u32 = 42;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE: u32 = 43;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_AUTOREACTIVE: u32 = 44;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_AUTOCOMPOSITION: u32 = 45;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_PREV_PRE_ALPHA_COLOR: u32 = 46;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_PREV_POST_ALPHA_COLOR: u32 = 47;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_PREV_PRE_ALPHA_COLOR_1: u32 = 48;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_PREV_POST_ALPHA_COLOR_1: u32 = 49;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_PREV_PRE_ALPHA_COLOR_2: u32 = 50;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_PREV_POST_ALPHA_COLOR_2: u32 = 51;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_PREVIOUS_DILATED_MOTION_VECTORS: u32 = 52;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_DILATED_MOTION_VECTORS_1: u32 = 53;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_DILATED_MOTION_VECTORS_2: u32 = 54;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_LUMA_HISTORY_1: u32 = 55;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_LUMA_HISTORY_2: u32 = 56;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_LOCK_INPUT_LUMA: u32 = 57;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_SCENE_LUMINANCE_MIPMAP_SHADING_CHANGE: u32 = 33;
pub const FFX_FSR2_SHADING_CHANGE_MIP_LEVEL: u32 = 4;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_COUNT: u32 = 58;
pub const FFX_FSR2_CONSTANTBUFFER_IDENTIFIER_FSR2: u32 = 0;
pub const FFX_FSR2_CONSTANTBUFFER_IDENTIFIER_SPD: u32 = 1;
pub const FFX_FSR2_CONSTANTBUFFER_IDENTIFIER_RCAS: u32 = 2;
pub const FFX_FSR2_CONSTANTBUFFER_IDENTIFIER_GENREACTIVE: u32 = 3;
pub const FFX_FSR2_AUTOREACTIVEFLAGS_APPLY_TONEMAP: u32 = 1;
pub const FFX_FSR2_AUTOREACTIVEFLAGS_APPLY_INVERSETONEMAP: u32 = 2;
pub const FFX_FSR2_AUTOREACTIVEFLAGS_APPLY_THRESHOLD: u32 = 4;
pub const FFX_FSR2_AUTOREACTIVEFLAGS_USE_COMPONENTS_MAX: u32 = 8;
pub const FFX_FSR2_VERSION_MAJOR: u32 = 2;
pub const FFX_FSR2_VERSION_MINOR: u32 = 2;
pub const FFX_FSR2_VERSION_PATCH: u32 = 0;
pub const FFX_FSR2_CONTEXT_SIZE: u32 = 16536;
pub type wchar_t = ::std::os::raw::c_int;
#[doc = "< Unknown format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_UNKNOWN: FfxSurfaceFormat = 0;
#[doc = "< 32 bit per channel, 4 channel\n< typeless format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R32G32B32A32_TYPELESS: FfxSurfaceFormat = 1;
#[doc = "< 32 bit per channel, 4 channel\n< float format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R32G32B32A32_FLOAT: FfxSurfaceFormat = 2;
#[doc = "< 16 bit per channel, 4 channel\n< float format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT: FfxSurfaceFormat = 3;
#[doc = "< 16 bit per channel, 4 channel\n< unsigned normalized format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R16G16B16A16_UNORM: FfxSurfaceFormat = 4;
#[doc = "< 32 bit per channel, 2 channel float\n< format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R32G32_FLOAT: FfxSurfaceFormat = 5;
#[doc = "< 32 bit per channel, 1 channel float format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R32_UINT: FfxSurfaceFormat = 6;
#[doc = "<  8 bit per channel, 4 channel float\n<  format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R8G8B8A8_TYPELESS: FfxSurfaceFormat = 7;
#[doc = "<  8 bit per channel, 4 channel unsigned\n<  normalized format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R8G8B8A8_UNORM: FfxSurfaceFormat = 8;
#[doc = "< 32 bit 3 channel float format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R11G11B10_FLOAT: FfxSurfaceFormat = 9;
#[doc = "< 16 bit per channel, 2 channel float\n< format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R16G16_FLOAT: FfxSurfaceFormat = 10;
#[doc = "< 16 bit per channel, 2 channel unsigned\n< int format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R16G16_UINT: FfxSurfaceFormat = 11;
#[doc = "< 16 bit per channel, 1 channel float format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R16_FLOAT: FfxSurfaceFormat = 12;
#[doc = "< 16 bit per channel, 1 channel unsigned int\n< format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R16_UINT: FfxSurfaceFormat = 13;
#[doc = "< 16 bit per channel, 1 channel unsigned\n< normalized format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R16_UNORM: FfxSurfaceFormat = 14;
#[doc = "< 16 bit per channel, 1 channel signed\n< normalized format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R16_SNORM: FfxSurfaceFormat = 15;
#[doc = "<  8 bit per channel, 1 channel unsigned\n<  normalized format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R8_UNORM: FfxSurfaceFormat = 16;
#[doc = "<  8 bit per channel, 1 channel unsigned int\n<  format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R8_UINT: FfxSurfaceFormat = 17;
#[doc = "<  8 bit per channel, 2 channel unsigned\n<  normalized format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R8G8_UNORM: FfxSurfaceFormat = 18;
#[doc = "< 32 bit per channel, 1 channel float format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R32_FLOAT: FfxSurfaceFormat = 19;
#[doc = " An enumeration of surface formats."]
pub type FfxSurfaceFormat = ::std::os::raw::c_uint;
pub const FfxResourceUsage_FFX_RESOURCE_USAGE_READ_ONLY: FfxResourceUsage = 0;
pub const FfxResourceUsage_FFX_RESOURCE_USAGE_RENDERTARGET: FfxResourceUsage = 1;
pub const FfxResourceUsage_FFX_RESOURCE_USAGE_UAV: FfxResourceUsage = 2;
#[doc = " An enumeration of resource usage."]
pub type FfxResourceUsage = ::std::os::raw::c_uint;
pub const FfxResourceStates_FFX_RESOURCE_STATE_UNORDERED_ACCESS: FfxResourceStates = 1;
pub const FfxResourceStates_FFX_RESOURCE_STATE_COMPUTE_READ: FfxResourceStates = 2;
pub const FfxResourceStates_FFX_RESOURCE_STATE_COPY_SRC: FfxResourceStates = 4;
pub const FfxResourceStates_FFX_RESOURCE_STATE_COPY_DEST: FfxResourceStates = 8;
pub const FfxResourceStates_FFX_RESOURCE_STATE_GENERIC_READ: FfxResourceStates = 6;
#[doc = " An enumeration of resource states."]
pub type FfxResourceStates = ::std::os::raw::c_uint;
#[doc = "< No flags."]
pub const FfxResourceFlags_FFX_RESOURCE_FLAGS_NONE: FfxResourceFlags = 0;
pub const FfxResourceFlags_FFX_RESOURCE_FLAGS_ALIASABLE: FfxResourceFlags = 1;
#[doc = " An enumeration of surface dimensions."]
pub type FfxResourceFlags = ::std::os::raw::c_uint;
#[doc = "< Point sampling."]
pub const FfxFilterType_FFX_FILTER_TYPE_POINT: FfxFilterType = 0;
#[doc = "< Sampling with interpolation."]
pub const FfxFilterType_FFX_FILTER_TYPE_LINEAR: FfxFilterType = 1;
#[doc = " The type of filtering to perform when reading a texture."]
pub type FfxFilterType = ::std::os::raw::c_uint;
#[doc = "< Shader model 5.1."]
pub const FfxShaderModel_FFX_SHADER_MODEL_5_1: FfxShaderModel = 0;
#[doc = "< Shader model 6.0."]
pub const FfxShaderModel_FFX_SHADER_MODEL_6_0: FfxShaderModel = 1;
#[doc = "< Shader model 6.1."]
pub const FfxShaderModel_FFX_SHADER_MODEL_6_1: FfxShaderModel = 2;
#[doc = "< Shader model 6.2."]
pub const FfxShaderModel_FFX_SHADER_MODEL_6_2: FfxShaderModel = 3;
#[doc = "< Shader model 6.3."]
pub const FfxShaderModel_FFX_SHADER_MODEL_6_3: FfxShaderModel = 4;
#[doc = "< Shader model 6.4."]
pub const FfxShaderModel_FFX_SHADER_MODEL_6_4: FfxShaderModel = 5;
#[doc = "< Shader model 6.5."]
pub const FfxShaderModel_FFX_SHADER_MODEL_6_5: FfxShaderModel = 6;
#[doc = "< Shader model 6.6."]
pub const FfxShaderModel_FFX_SHADER_MODEL_6_6: FfxShaderModel = 7;
#[doc = "< Shader model 6.7."]
pub const FfxShaderModel_FFX_SHADER_MODEL_6_7: FfxShaderModel = 8;
#[doc = " An enumeration of all supported shader models."]
pub type FfxShaderModel = ::std::os::raw::c_uint;
#[doc = "< The resource is a buffer."]
pub const FfxResourceType_FFX_RESOURCE_TYPE_BUFFER: FfxResourceType = 0;
#[doc = "< The resource is a 1-dimensional texture."]
pub const FfxResourceType_FFX_RESOURCE_TYPE_TEXTURE1D: FfxResourceType = 1;
#[doc = "< The resource is a 2-dimensional texture."]
pub const FfxResourceType_FFX_RESOURCE_TYPE_TEXTURE2D: FfxResourceType = 2;
#[doc = "< The resource is a 3-dimensional texture."]
pub const FfxResourceType_FFX_RESOURCE_TYPE_TEXTURE3D: FfxResourceType = 3;
pub type FfxResourceType = ::std::os::raw::c_uint;
#[doc = "< Local memory."]
pub const FfxHeapType_FFX_HEAP_TYPE_DEFAULT: FfxHeapType = 0;
#[doc = "< Heap used for uploading resources."]
pub const FfxHeapType_FFX_HEAP_TYPE_UPLOAD: FfxHeapType = 1;
#[doc = " An enumeration for different heap types"]
pub type FfxHeapType = ::std::os::raw::c_uint;
pub const FfxGpuJobType_FFX_GPU_JOB_CLEAR_FLOAT: FfxGpuJobType = 0;
#[doc = "< The GPU job is performing a copy."]
pub const FfxGpuJobType_FFX_GPU_JOB_COPY: FfxGpuJobType = 1;
#[doc = "< The GPU job is performing a compute dispatch."]
pub const FfxGpuJobType_FFX_GPU_JOB_COMPUTE: FfxGpuJobType = 2;
#[doc = " An enumberation for different render job types"]
pub type FfxGpuJobType = ::std::os::raw::c_uint;
#[doc = " A typedef representing the graphics device."]
pub type FfxDevice = *mut ::std::os::raw::c_void;
#[doc = " A typedef representing a command list or command buffer."]
pub type FfxCommandList = *mut ::std::os::raw::c_void;
#[doc = " A typedef for a root signature."]
pub type FfxRootSignature = *mut ::std::os::raw::c_void;
#[doc = " A typedef for a pipeline state object."]
pub type FfxPipeline = *mut ::std::os::raw::c_void;
#[doc = " A structure encapasulating a collection of device capabilities."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxDeviceCapabilities {
    #[doc = "< The minimum shader model\n< supported by the device."]
    pub minimumSupportedShaderModel: FfxShaderModel,
    #[doc = "< The minimum supported wavefront width."]
    pub waveLaneCountMin: u32,
    #[doc = "< The maximum supported wavefront width."]
    pub waveLaneCountMax: u32,
    #[doc = "< The device supports FP16 in hardware."]
    pub fp16Supported: bool,
    #[doc = "< The device supports raytracing."]
    pub raytracingSupported: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxDeviceCapabilities"][::std::mem::size_of::<FfxDeviceCapabilities>() - 16usize];
    ["Alignment of FfxDeviceCapabilities"]
        [::std::mem::align_of::<FfxDeviceCapabilities>() - 4usize];
    ["Offset of field: FfxDeviceCapabilities::minimumSupportedShaderModel"]
        [::std::mem::offset_of!(FfxDeviceCapabilities, minimumSupportedShaderModel) - 0usize];
    ["Offset of field: FfxDeviceCapabilities::waveLaneCountMin"]
        [::std::mem::offset_of!(FfxDeviceCapabilities, waveLaneCountMin) - 4usize];
    ["Offset of field: FfxDeviceCapabilities::waveLaneCountMax"]
        [::std::mem::offset_of!(FfxDeviceCapabilities, waveLaneCountMax) - 8usize];
    ["Offset of field: FfxDeviceCapabilities::fp16Supported"]
        [::std::mem::offset_of!(FfxDeviceCapabilities, fp16Supported) - 12usize];
    ["Offset of field: FfxDeviceCapabilities::raytracingSupported"]
        [::std::mem::offset_of!(FfxDeviceCapabilities, raytracingSupported) - 13usize];
};
#[doc = " A structure encapsulating a 2-dimensional point, using 32bit unsigned\n integers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxDimensions2D {
    #[doc = "< The width of a 2-dimensional range."]
    pub width: u32,
    #[doc = "< The height of a 2-dimensional range."]
    pub height: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxDimensions2D"][::std::mem::size_of::<FfxDimensions2D>() - 8usize];
    ["Alignment of FfxDimensions2D"][::std::mem::align_of::<FfxDimensions2D>() - 4usize];
    ["Offset of field: FfxDimensions2D::width"]
        [::std::mem::offset_of!(FfxDimensions2D, width) - 0usize];
    ["Offset of field: FfxDimensions2D::height"]
        [::std::mem::offset_of!(FfxDimensions2D, height) - 4usize];
};
#[doc = " A structure encapsulating a 2-dimensional set of floating point coordinates."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxFloatCoords2D {
    #[doc = "< The x coordinate of a 2-dimensional point."]
    pub x: f32,
    #[doc = "< The y coordinate of a 2-dimensional point."]
    pub y: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxFloatCoords2D"][::std::mem::size_of::<FfxFloatCoords2D>() - 8usize];
    ["Alignment of FfxFloatCoords2D"][::std::mem::align_of::<FfxFloatCoords2D>() - 4usize];
    ["Offset of field: FfxFloatCoords2D::x"][::std::mem::offset_of!(FfxFloatCoords2D, x) - 0usize];
    ["Offset of field: FfxFloatCoords2D::y"][::std::mem::offset_of!(FfxFloatCoords2D, y) - 4usize];
};
#[doc = " A structure describing a resource."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxResourceDescription {
    #[doc = "< The type of the resource."]
    pub type_: FfxResourceType,
    #[doc = "< The surface format."]
    pub format: FfxSurfaceFormat,
    #[doc = "< The width of the resource."]
    pub width: u32,
    #[doc = "< The height of the resource."]
    pub height: u32,
    #[doc = "< The depth of the resource."]
    pub depth: u32,
    #[doc = "< Number of mips (or 0 for full mipchain)."]
    pub mipCount: u32,
    #[doc = "< A set of <c><i>FfxResourceFlags</i></c> flags."]
    pub flags: FfxResourceFlags,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxResourceDescription"][::std::mem::size_of::<FfxResourceDescription>() - 28usize];
    ["Alignment of FfxResourceDescription"]
        [::std::mem::align_of::<FfxResourceDescription>() - 4usize];
    ["Offset of field: FfxResourceDescription::type_"]
        [::std::mem::offset_of!(FfxResourceDescription, type_) - 0usize];
    ["Offset of field: FfxResourceDescription::format"]
        [::std::mem::offset_of!(FfxResourceDescription, format) - 4usize];
    ["Offset of field: FfxResourceDescription::width"]
        [::std::mem::offset_of!(FfxResourceDescription, width) - 8usize];
    ["Offset of field: FfxResourceDescription::height"]
        [::std::mem::offset_of!(FfxResourceDescription, height) - 12usize];
    ["Offset of field: FfxResourceDescription::depth"]
        [::std::mem::offset_of!(FfxResourceDescription, depth) - 16usize];
    ["Offset of field: FfxResourceDescription::mipCount"]
        [::std::mem::offset_of!(FfxResourceDescription, mipCount) - 20usize];
    ["Offset of field: FfxResourceDescription::flags"]
        [::std::mem::offset_of!(FfxResourceDescription, flags) - 24usize];
};
#[doc = " An outward facing structure containing a resource"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxResource {
    #[doc = "< pointer to the resource."]
    pub resource: *mut ::std::os::raw::c_void,
    pub name: [wchar_t; 64usize],
    pub description: FfxResourceDescription,
    pub state: FfxResourceStates,
    pub isDepth: bool,
    pub descriptorData: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxResource"][::std::mem::size_of::<FfxResource>() - 312usize];
    ["Alignment of FfxResource"][::std::mem::align_of::<FfxResource>() - 8usize];
    ["Offset of field: FfxResource::resource"]
        [::std::mem::offset_of!(FfxResource, resource) - 0usize];
    ["Offset of field: FfxResource::name"][::std::mem::offset_of!(FfxResource, name) - 8usize];
    ["Offset of field: FfxResource::description"]
        [::std::mem::offset_of!(FfxResource, description) - 264usize];
    ["Offset of field: FfxResource::state"][::std::mem::offset_of!(FfxResource, state) - 292usize];
    ["Offset of field: FfxResource::isDepth"]
        [::std::mem::offset_of!(FfxResource, isDepth) - 296usize];
    ["Offset of field: FfxResource::descriptorData"]
        [::std::mem::offset_of!(FfxResource, descriptorData) - 304usize];
};
#[doc = " An internal structure containing a handle to a resource and resource views"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxResourceInternal {
    #[doc = "< The index of the resource."]
    pub internalIndex: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxResourceInternal"][::std::mem::size_of::<FfxResourceInternal>() - 4usize];
    ["Alignment of FfxResourceInternal"][::std::mem::align_of::<FfxResourceInternal>() - 4usize];
    ["Offset of field: FfxResourceInternal::internalIndex"]
        [::std::mem::offset_of!(FfxResourceInternal, internalIndex) - 0usize];
};
#[doc = " A structure defining a resource bind point"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxResourceBinding {
    pub slotIndex: u32,
    pub resourceIdentifier: u32,
    pub name: [wchar_t; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxResourceBinding"][::std::mem::size_of::<FfxResourceBinding>() - 264usize];
    ["Alignment of FfxResourceBinding"][::std::mem::align_of::<FfxResourceBinding>() - 4usize];
    ["Offset of field: FfxResourceBinding::slotIndex"]
        [::std::mem::offset_of!(FfxResourceBinding, slotIndex) - 0usize];
    ["Offset of field: FfxResourceBinding::resourceIdentifier"]
        [::std::mem::offset_of!(FfxResourceBinding, resourceIdentifier) - 4usize];
    ["Offset of field: FfxResourceBinding::name"]
        [::std::mem::offset_of!(FfxResourceBinding, name) - 8usize];
};
#[doc = " A structure encapsulating a single pass of an algorithm."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxPipelineState {
    #[doc = "< The pipelines rootSignature"]
    pub rootSignature: FfxRootSignature,
    #[doc = "< The pipeline object"]
    pub pipeline: FfxPipeline,
    #[doc = "< Count of UAVs used in this pipeline"]
    pub uavCount: u32,
    #[doc = "< Count of SRVs used in this pipeline"]
    pub srvCount: u32,
    #[doc = "< Count of constant buffers used in this pipeline"]
    pub constCount: u32,
    #[doc = "< Array of ResourceIdentifiers\n< bound as UAVs"]
    pub uavResourceBindings: [FfxResourceBinding; 8usize],
    #[doc = "< Array of ResourceIdentifiers\n< bound as SRVs"]
    pub srvResourceBindings: [FfxResourceBinding; 16usize],
    #[doc = "< Array of\n< ResourceIdentifiers\n< bound as CBs"]
    pub cbResourceBindings: [FfxResourceBinding; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxPipelineState"][::std::mem::size_of::<FfxPipelineState>() - 6896usize];
    ["Alignment of FfxPipelineState"][::std::mem::align_of::<FfxPipelineState>() - 8usize];
    ["Offset of field: FfxPipelineState::rootSignature"]
        [::std::mem::offset_of!(FfxPipelineState, rootSignature) - 0usize];
    ["Offset of field: FfxPipelineState::pipeline"]
        [::std::mem::offset_of!(FfxPipelineState, pipeline) - 8usize];
    ["Offset of field: FfxPipelineState::uavCount"]
        [::std::mem::offset_of!(FfxPipelineState, uavCount) - 16usize];
    ["Offset of field: FfxPipelineState::srvCount"]
        [::std::mem::offset_of!(FfxPipelineState, srvCount) - 20usize];
    ["Offset of field: FfxPipelineState::constCount"]
        [::std::mem::offset_of!(FfxPipelineState, constCount) - 24usize];
    ["Offset of field: FfxPipelineState::uavResourceBindings"]
        [::std::mem::offset_of!(FfxPipelineState, uavResourceBindings) - 28usize];
    ["Offset of field: FfxPipelineState::srvResourceBindings"]
        [::std::mem::offset_of!(FfxPipelineState, srvResourceBindings) - 2140usize];
    ["Offset of field: FfxPipelineState::cbResourceBindings"]
        [::std::mem::offset_of!(FfxPipelineState, cbResourceBindings) - 6364usize];
};
#[doc = " A structure containing the data required to create a resource."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxCreateResourceDescription {
    #[doc = "< The heap type to hold the resource, typically\n< <c><i>FFX_HEAP_TYPE_DEFAULT</i></c>."]
    pub heapType: FfxHeapType,
    #[doc = "< A resource description."]
    pub resourceDescription: FfxResourceDescription,
    #[doc = "< The initial resource state."]
    pub initalState: FfxResourceStates,
    #[doc = "< Size of initial data buffer."]
    pub initDataSize: u32,
    #[doc = "< Buffer containing data to fill the resource."]
    pub initData: *mut ::std::os::raw::c_void,
    #[doc = "< Name of the resource."]
    pub name: *const wchar_t,
    #[doc = "< Resource usage flags."]
    pub usage: FfxResourceUsage,
    #[doc = "< Internal resource ID."]
    pub id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxCreateResourceDescription"]
        [::std::mem::size_of::<FfxCreateResourceDescription>() - 64usize];
    ["Alignment of FfxCreateResourceDescription"]
        [::std::mem::align_of::<FfxCreateResourceDescription>() - 8usize];
    ["Offset of field: FfxCreateResourceDescription::heapType"]
        [::std::mem::offset_of!(FfxCreateResourceDescription, heapType) - 0usize];
    ["Offset of field: FfxCreateResourceDescription::resourceDescription"]
        [::std::mem::offset_of!(FfxCreateResourceDescription, resourceDescription) - 4usize];
    ["Offset of field: FfxCreateResourceDescription::initalState"]
        [::std::mem::offset_of!(FfxCreateResourceDescription, initalState) - 32usize];
    ["Offset of field: FfxCreateResourceDescription::initDataSize"]
        [::std::mem::offset_of!(FfxCreateResourceDescription, initDataSize) - 36usize];
    ["Offset of field: FfxCreateResourceDescription::initData"]
        [::std::mem::offset_of!(FfxCreateResourceDescription, initData) - 40usize];
    ["Offset of field: FfxCreateResourceDescription::name"]
        [::std::mem::offset_of!(FfxCreateResourceDescription, name) - 48usize];
    ["Offset of field: FfxCreateResourceDescription::usage"]
        [::std::mem::offset_of!(FfxCreateResourceDescription, usage) - 56usize];
    ["Offset of field: FfxCreateResourceDescription::id"]
        [::std::mem::offset_of!(FfxCreateResourceDescription, id) - 60usize];
};
#[doc = " A structure containing the description used to create a\n <c><i>FfxPipeline</i></c> structure.\n\n A pipeline is the name given to a shader and the collection of state that\n is required to dispatch it. In the context of FSR2 and its architecture\n this means that a <c><i>FfxPipelineDescription</i></c> will map to either a\n monolithic object in an explicit API (such as a\n <c><i>PipelineStateObject</i></c> in DirectX 12). Or a shader and some\n ancillary API objects (in something like DirectX 11).\n\n The <c><i>contextFlags</i></c> field contains a copy of the flags passed\n to <c><i>ffxFsr2ContextCreate</i></c> via the <c><i>flags</i></c> field of\n the <c><i>FfxFsr2InitializationParams</i></c> structure. These flags are\n used to determine which permutation of a pipeline for a specific\n <c><i>FfxFsr2Pass</i></c> should be used to implement the features required\n by each application, as well as to acheive the best performance on specific\n target hardware configurations.\n\n When using one of the provided backends for FSR2 (such as DirectX 12 or\n Vulkan) the data required to create a pipeline is compiled offline and\n included into the backend library that you are using. For cases where the\n backend interface is overriden by providing custom callback function\n implementations care should be taken to respect the contents of the\n <c><i>contextFlags</i></c> field in order to correctly support the options\n provided by FSR2, and acheive best performance.\n\n @ingroup FSR2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxPipelineDescription {
    #[doc = "< A collection of\n< <c><i>FfxFsr2InitializationFlagBits</i></c> which\n< were passed to the context."]
    pub contextFlags: u32,
    #[doc = "< Array of static samplers."]
    pub samplers: *mut FfxFilterType,
    #[doc = "< The number of samples contained inside\n< <c><i>samplers</i></c>."]
    pub samplerCount: usize,
    #[doc = "< Array containing the sizes of the root\n< constant buffers (count of 32 bit elements)."]
    pub rootConstantBufferSizes: *const u32,
    #[doc = "< The number of root constants contained\n< within\n< <c><i>rootConstantBufferSizes</i></c>."]
    pub rootConstantBufferCount: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxPipelineDescription"][::std::mem::size_of::<FfxPipelineDescription>() - 40usize];
    ["Alignment of FfxPipelineDescription"]
        [::std::mem::align_of::<FfxPipelineDescription>() - 8usize];
    ["Offset of field: FfxPipelineDescription::contextFlags"]
        [::std::mem::offset_of!(FfxPipelineDescription, contextFlags) - 0usize];
    ["Offset of field: FfxPipelineDescription::samplers"]
        [::std::mem::offset_of!(FfxPipelineDescription, samplers) - 8usize];
    ["Offset of field: FfxPipelineDescription::samplerCount"]
        [::std::mem::offset_of!(FfxPipelineDescription, samplerCount) - 16usize];
    ["Offset of field: FfxPipelineDescription::rootConstantBufferSizes"]
        [::std::mem::offset_of!(FfxPipelineDescription, rootConstantBufferSizes) - 24usize];
    ["Offset of field: FfxPipelineDescription::rootConstantBufferCount"]
        [::std::mem::offset_of!(FfxPipelineDescription, rootConstantBufferCount) - 32usize];
};
#[doc = " A structure containing a constant buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxConstantBuffer {
    #[doc = "< Size of 32 bit chunks used in the constant buffer"]
    pub uint32Size: u32,
    #[doc = "< Constant buffer data"]
    pub data: [u32; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxConstantBuffer"][::std::mem::size_of::<FfxConstantBuffer>() - 260usize];
    ["Alignment of FfxConstantBuffer"][::std::mem::align_of::<FfxConstantBuffer>() - 4usize];
    ["Offset of field: FfxConstantBuffer::uint32Size"]
        [::std::mem::offset_of!(FfxConstantBuffer, uint32Size) - 0usize];
    ["Offset of field: FfxConstantBuffer::data"]
        [::std::mem::offset_of!(FfxConstantBuffer, data) - 4usize];
};
#[doc = " A structure describing a clear render job."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxClearFloatJobDescription {
    #[doc = "< The clear color of the resource."]
    pub color: [f32; 4usize],
    #[doc = "< The resource to be cleared."]
    pub target: FfxResourceInternal,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxClearFloatJobDescription"]
        [::std::mem::size_of::<FfxClearFloatJobDescription>() - 20usize];
    ["Alignment of FfxClearFloatJobDescription"]
        [::std::mem::align_of::<FfxClearFloatJobDescription>() - 4usize];
    ["Offset of field: FfxClearFloatJobDescription::color"]
        [::std::mem::offset_of!(FfxClearFloatJobDescription, color) - 0usize];
    ["Offset of field: FfxClearFloatJobDescription::target"]
        [::std::mem::offset_of!(FfxClearFloatJobDescription, target) - 16usize];
};
#[doc = " A structure describing a compute render job."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxComputeJobDescription {
    #[doc = "< Compute pipeline for the render job."]
    pub pipeline: FfxPipelineState,
    #[doc = "< Dispatch dimensions."]
    pub dimensions: [u32; 3usize],
    #[doc = "< SRV resources to be bound in the compute job."]
    pub srvs: [FfxResourceInternal; 16usize],
    pub srvNames: [[wchar_t; 64usize]; 16usize],
    #[doc = "< UAV resources to be bound in the compute job."]
    pub uavs: [FfxResourceInternal; 8usize],
    #[doc = "< Mip level of UAV resources to be bound\n< in the compute job."]
    pub uavMip: [u32; 8usize],
    pub uavNames: [[wchar_t; 64usize]; 8usize],
    #[doc = "< Constant buffers to be bound in the\n< compute job."]
    pub cbs: [FfxConstantBuffer; 2usize],
    pub cbNames: [[wchar_t; 64usize]; 2usize],
    #[doc = "< Slot index in the\n< descriptor table"]
    pub cbSlotIndex: [u32; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxComputeJobDescription"]
        [::std::mem::size_of::<FfxComputeJobDescription>() - 14224usize];
    ["Alignment of FfxComputeJobDescription"]
        [::std::mem::align_of::<FfxComputeJobDescription>() - 8usize];
    ["Offset of field: FfxComputeJobDescription::pipeline"]
        [::std::mem::offset_of!(FfxComputeJobDescription, pipeline) - 0usize];
    ["Offset of field: FfxComputeJobDescription::dimensions"]
        [::std::mem::offset_of!(FfxComputeJobDescription, dimensions) - 6896usize];
    ["Offset of field: FfxComputeJobDescription::srvs"]
        [::std::mem::offset_of!(FfxComputeJobDescription, srvs) - 6908usize];
    ["Offset of field: FfxComputeJobDescription::srvNames"]
        [::std::mem::offset_of!(FfxComputeJobDescription, srvNames) - 6972usize];
    ["Offset of field: FfxComputeJobDescription::uavs"]
        [::std::mem::offset_of!(FfxComputeJobDescription, uavs) - 11068usize];
    ["Offset of field: FfxComputeJobDescription::uavMip"]
        [::std::mem::offset_of!(FfxComputeJobDescription, uavMip) - 11100usize];
    ["Offset of field: FfxComputeJobDescription::uavNames"]
        [::std::mem::offset_of!(FfxComputeJobDescription, uavNames) - 11132usize];
    ["Offset of field: FfxComputeJobDescription::cbs"]
        [::std::mem::offset_of!(FfxComputeJobDescription, cbs) - 13180usize];
    ["Offset of field: FfxComputeJobDescription::cbNames"]
        [::std::mem::offset_of!(FfxComputeJobDescription, cbNames) - 13700usize];
    ["Offset of field: FfxComputeJobDescription::cbSlotIndex"]
        [::std::mem::offset_of!(FfxComputeJobDescription, cbSlotIndex) - 14212usize];
};
#[doc = " A structure describing a copy render job."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxCopyJobDescription {
    #[doc = "< Source resource for the copy."]
    pub src: FfxResourceInternal,
    #[doc = "< Destination resource for the copy."]
    pub dst: FfxResourceInternal,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxCopyJobDescription"][::std::mem::size_of::<FfxCopyJobDescription>() - 8usize];
    ["Alignment of FfxCopyJobDescription"]
        [::std::mem::align_of::<FfxCopyJobDescription>() - 4usize];
    ["Offset of field: FfxCopyJobDescription::src"]
        [::std::mem::offset_of!(FfxCopyJobDescription, src) - 0usize];
    ["Offset of field: FfxCopyJobDescription::dst"]
        [::std::mem::offset_of!(FfxCopyJobDescription, dst) - 4usize];
};
#[doc = " A structure describing a single render job."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FfxGpuJobDescription {
    #[doc = "< Type of the job."]
    pub jobType: FfxGpuJobType,
    pub __bindgen_anon_1: FfxGpuJobDescription__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FfxGpuJobDescription__bindgen_ty_1 {
    #[doc = "< Clear job descriptor. Valid when\n< <c><i>jobType</i></c> is\n< <c><i>FFX_RENDER_JOB_CLEAR_FLOAT</i></c>."]
    pub clearJobDescriptor: FfxClearFloatJobDescription,
    #[doc = "< Copy job descriptor. Valid when\n< <c><i>jobType</i></c> is\n< <c><i>FFX_RENDER_JOB_COPY</i></c>."]
    pub copyJobDescriptor: FfxCopyJobDescription,
    #[doc = "< Compute job descriptor. Valid when\n< <c><i>jobType</i></c> is\n< <c><i>FFX_RENDER_JOB_COMPUTE</i></c>."]
    pub computeJobDescriptor: FfxComputeJobDescription,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxGpuJobDescription__bindgen_ty_1"]
        [::std::mem::size_of::<FfxGpuJobDescription__bindgen_ty_1>() - 14224usize];
    ["Alignment of FfxGpuJobDescription__bindgen_ty_1"]
        [::std::mem::align_of::<FfxGpuJobDescription__bindgen_ty_1>() - 8usize];
    ["Offset of field: FfxGpuJobDescription__bindgen_ty_1::clearJobDescriptor"]
        [::std::mem::offset_of!(FfxGpuJobDescription__bindgen_ty_1, clearJobDescriptor) - 0usize];
    ["Offset of field: FfxGpuJobDescription__bindgen_ty_1::copyJobDescriptor"]
        [::std::mem::offset_of!(FfxGpuJobDescription__bindgen_ty_1, copyJobDescriptor) - 0usize];
    ["Offset of field: FfxGpuJobDescription__bindgen_ty_1::computeJobDescriptor"]
        [::std::mem::offset_of!(FfxGpuJobDescription__bindgen_ty_1, computeJobDescriptor) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxGpuJobDescription"][::std::mem::size_of::<FfxGpuJobDescription>() - 14232usize];
    ["Alignment of FfxGpuJobDescription"][::std::mem::align_of::<FfxGpuJobDescription>() - 8usize];
    ["Offset of field: FfxGpuJobDescription::jobType"]
        [::std::mem::offset_of!(FfxGpuJobDescription, jobType) - 0usize];
};
#[doc = " The value of Pi."]
pub const FFX_PI: f32 = 3.1415927410125732;
#[doc = " An epsilon value for floating point numbers."]
pub const FFX_EPSILON: f32 = 0.0000009999999974752427;
#[doc = " A typedef for the callback function for assert printing.\n\n This can be used to re-route printing of assert messages from the FFX backend\n to another destination. For example instead of the default behaviour of printing\n the assert messages to the debugger's TTY the message can be re-routed to a\n MessageBox in a GUI application.\n\n @param [in] message                 The message generated by the assert.\n"]
pub type FfxAssertCallback =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;
extern "C" {
    #[doc = " Function to report an assert.\n\n @param [in] file                    The name of the file as a string.\n @param [in] line                    The index of the line in the file.\n @param [in] condition               The boolean condition that was tested.\n @param [in] msg                     The optional message to print.\n\n @returns\n Always returns true.\n"]
    pub fn ffxAssertReport(
        file: *const ::std::os::raw::c_char,
        line: i32,
        condition: *const ::std::os::raw::c_char,
        msg: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Provides the ability to set a callback for assert messages.\n\n @param [in] callback                The callback function that will receive assert messages.\n"]
    pub fn ffxAssertSetPrintingCallback(callback: FfxAssertCallback);
}
#[doc = " Typedef for error codes returned from functions in the FidelityFX SDK."]
pub type FfxErrorCode = i32;
#[doc = "< The operation completed successfully."]
pub const FFX_OK: FfxErrorCode = 0;
pub const FFX_ERROR_INVALID_POINTER: FfxErrorCode = -2147483648;
pub const FFX_ERROR_INVALID_ALIGNMENT: FfxErrorCode = -2147483647;
pub const FFX_ERROR_INVALID_SIZE: FfxErrorCode = -2147483646;
pub const FFX_EOF: FfxErrorCode = -2147483645;
pub const FFX_ERROR_INVALID_PATH: FfxErrorCode = -2147483644;
pub const FFX_ERROR_EOF: FfxErrorCode = -2147483643;
pub const FFX_ERROR_MALFORMED_DATA: FfxErrorCode = -2147483642;
pub const FFX_ERROR_OUT_OF_MEMORY: FfxErrorCode = -2147483641;
pub const FFX_ERROR_INCOMPLETE_INTERFACE: FfxErrorCode = -2147483640;
pub const FFX_ERROR_INVALID_ENUM: FfxErrorCode = -2147483639;
pub const FFX_ERROR_INVALID_ARGUMENT: FfxErrorCode = -2147483638;
pub const FFX_ERROR_OUT_OF_RANGE: FfxErrorCode = -2147483637;
pub const FFX_ERROR_NULL_DEVICE: FfxErrorCode = -2147483636;
pub const FFX_ERROR_BACKEND_API_ERROR: FfxErrorCode = -2147483635;
pub const FFX_ERROR_INSUFFICIENT_MEMORY: FfxErrorCode = -2147483634;
#[doc = "< A pass which performs depth clipping."]
pub const FfxFsr2Pass_FFX_FSR2_PASS_DEPTH_CLIP: FfxFsr2Pass = 0;
#[doc = "< A pass which performs reconstruction of previous frame's depth."]
pub const FfxFsr2Pass_FFX_FSR2_PASS_RECONSTRUCT_PREVIOUS_DEPTH: FfxFsr2Pass = 1;
#[doc = "< A pass which calculates pixel locks."]
pub const FfxFsr2Pass_FFX_FSR2_PASS_LOCK: FfxFsr2Pass = 2;
#[doc = "< A pass which performs upscaling."]
pub const FfxFsr2Pass_FFX_FSR2_PASS_ACCUMULATE: FfxFsr2Pass = 3;
#[doc = "< A pass which performs upscaling when sharpening is used."]
pub const FfxFsr2Pass_FFX_FSR2_PASS_ACCUMULATE_SHARPEN: FfxFsr2Pass = 4;
#[doc = "< A pass which performs sharpening."]
pub const FfxFsr2Pass_FFX_FSR2_PASS_RCAS: FfxFsr2Pass = 5;
#[doc = "< A pass which generates the luminance mipmap chain for the current frame."]
pub const FfxFsr2Pass_FFX_FSR2_PASS_COMPUTE_LUMINANCE_PYRAMID: FfxFsr2Pass = 6;
#[doc = "< An optional pass to generate a reactive mask"]
pub const FfxFsr2Pass_FFX_FSR2_PASS_GENERATE_REACTIVE: FfxFsr2Pass = 7;
#[doc = "< An optional pass to generate a texture-and-composition and reactive masks"]
pub const FfxFsr2Pass_FFX_FSR2_PASS_TCR_AUTOGENERATE: FfxFsr2Pass = 8;
#[doc = "< The number of passes performed by FSR2."]
pub const FfxFsr2Pass_FFX_FSR2_PASS_COUNT: FfxFsr2Pass = 9;
#[doc = " An enumeration of all the passes which constitute the FSR2 algorithm.\n\n FSR2 is implemented as a composite of several compute passes each\n computing a key part of the final result. Each call to the\n <c><i>FfxFsr2ScheduleGpuJobFunc</i></c> callback function will\n correspond to a single pass included in <c><i>FfxFsr2Pass</i></c>. For a\n more comprehensive description of each pass, please refer to the FSR2\n reference documentation.\n\n Please note in some cases e.g.: <c><i>FFX_FSR2_PASS_ACCUMULATE</i></c>\n and <c><i>FFX_FSR2_PASS_ACCUMULATE_SHARPEN</i></c> either one pass or the\n other will be used (they are mutually exclusive). The choice of which will\n depend on the way the <c><i>FfxFsr2Context</i></c> is created and the\n precise contents of <c><i>FfxFsr2DispatchParamters</i></c> each time a call\n is made to <c><i>ffxFsr2ContextDispatch</i></c>.\n\n @ingroup FSR2"]
pub type FfxFsr2Pass = ::std::os::raw::c_uint;
pub const FfxFsr2MsgType_FFX_FSR2_MESSAGE_TYPE_ERROR: FfxFsr2MsgType = 0;
pub const FfxFsr2MsgType_FFX_FSR2_MESSAGE_TYPE_WARNING: FfxFsr2MsgType = 1;
pub const FfxFsr2MsgType_FFX_FSR2_MESSAGE_TYPE_COUNT: FfxFsr2MsgType = 2;
pub type FfxFsr2MsgType = ::std::os::raw::c_uint;
#[doc = " Create and initialize the backend context.\n\n The callback function sets up the backend context for rendering.\n It will create or reference the device and create required internal data structures.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] device                              The FfxDevice obtained by ffxGetDevice(DX12/VK/...).\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2CreateBackendContextFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        device: FfxDevice,
    ) -> FfxErrorCode,
>;
#[doc = " Get a list of capabilities of the device.\n\n When creating an <c><i>FfxFsr2Context</i></c> it is desirable for the FSR2\n core implementation to be aware of certain characteristics of the platform\n that is being targetted. This is because some optimizations which FSR2\n attempts to perform are more effective on certain classes of hardware than\n others, or are not supported by older hardware. In order to avoid cases\n where optimizations actually have the effect of decreasing performance, or\n reduce the breadth of support provided by FSR2, FSR2 queries the\n capabilities of the device to make such decisions.\n\n For target platforms with fixed hardware support you need not implement\n this callback function by querying the device, but instead may hardcore\n what features are available on the platform.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [out] outDeviceCapabilities              The device capabilities structure to fill out.\n @param [in] device                              The device to query for capabilities.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2GetDeviceCapabilitiesFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        outDeviceCapabilities: *mut FfxDeviceCapabilities,
        device: FfxDevice,
    ) -> FfxErrorCode,
>;
#[doc = " Destroy the backend context and dereference the device.\n\n This function is called when the <c><i>FfxFsr2Context</i></c> is destroyed.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2DestroyBackendContextFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut FfxFsr2Interface) -> FfxErrorCode,
>;
#[doc = " Create a resource.\n\n This callback is intended for the backend to create internal resources.\n\n Please note: It is also possible that the creation of resources might\n itself cause additional resources to be created by simply calling the\n <c><i>FfxFsr2CreateResourceFunc</i></c> function pointer again. This is\n useful when handling the initial creation of resources which must be\n initialized. The flow in such a case would be an initial call to create the\n CPU-side resource, another to create the GPU-side resource, and then a call\n to schedule a copy render job to move the data between the two. Typically\n this type of function call flow is only seen during the creation of an\n <c><i>FfxFsr2Context</i></c>.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] createResourceDescription           A pointer to a <c><i>FfxCreateResourceDescription</i></c>.\n @param [out] outResource                        A pointer to a <c><i>FfxResource</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2CreateResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        createResourceDescription: *const FfxCreateResourceDescription,
        outResource: *mut FfxResourceInternal,
    ) -> FfxErrorCode,
>;
#[doc = " Register a resource in the backend for the current frame.\n\n Since FSR2 and the backend are not aware how many different\n resources will get passed to FSR2 over time, it's not safe\n to register all resources simultaneously in the backend.\n Also passed resources may not be valid after the dispatch call.\n As a result it's safest to register them as FfxResourceInternal\n and clear them at the end of the dispatch call.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] inResource                          A pointer to a <c><i>FfxResource</i></c>.\n @param [out] outResource                        A pointer to a <c><i>FfxResourceInternal</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2RegisterResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        inResource: *const FfxResource,
        outResource: *mut FfxResourceInternal,
    ) -> FfxErrorCode,
>;
#[doc = " Unregister all temporary FfxResourceInternal from the backend.\n\n Unregister FfxResourceInternal referencing resources passed to\n a function as a parameter.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2UnregisterResourcesFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut FfxFsr2Interface) -> FfxErrorCode,
>;
#[doc = " Retrieve a <c><i>FfxResourceDescription</i></c> matching a\n <c><i>FfxResource</i></c> structure.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n\n @returns\n A description of the resource.\n\n @ingroup FSR2"]
pub type FfxFsr2GetResourceDescriptionFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        resource: FfxResourceInternal,
    ) -> FfxResourceDescription,
>;
#[doc = " Destroy a resource\n\n This callback is intended for the backend to release an internal resource.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2DestroyResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        resource: FfxResourceInternal,
    ) -> FfxErrorCode,
>;
#[doc = " Create a render pipeline.\n\n A rendering pipeline contains the shader as well as resource bindpoints\n and samplers.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] pass                                The identifier for the pass.\n @param [in] pipelineDescription                 A pointer to a <c><i>FfxPipelineDescription</i></c> describing the pipeline to be created.\n @param [out] outPipeline                        A pointer to a <c><i>FfxPipelineState</i></c> structure which should be populated.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2CreatePipelineFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        pass: FfxFsr2Pass,
        pipelineDescription: *const FfxPipelineDescription,
        outPipeline: *mut FfxPipelineState,
    ) -> FfxErrorCode,
>;
#[doc = " Destroy a render pipeline.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [out] pipeline                           A pointer to a <c><i>FfxPipelineState</i></c> structure which should be released.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2DestroyPipelineFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        pipeline: *mut FfxPipelineState,
    ) -> FfxErrorCode,
>;
#[doc = " Schedule a render job to be executed on the next call of\n <c><i>FfxFsr2ExecuteGpuJobsFunc</i></c>.\n\n Render jobs can perform one of three different tasks: clear, copy or\n compute dispatches.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] job                                 A pointer to a <c><i>FfxGpuJobDescription</i></c> structure.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2ScheduleGpuJobFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        job: *const FfxGpuJobDescription,
    ) -> FfxErrorCode,
>;
#[doc = " Execute scheduled render jobs on the <c><i>comandList</i></c> provided.\n\n The recording of the graphics API commands should take place in this\n callback function, the render jobs which were previously enqueued (via\n callbacks made to <c><i>FfxFsr2ScheduleGpuJobFunc</i></c>) should be\n processed in the order they were received. Advanced users might choose to\n reorder the rendering jobs, but should do so with care to respect the\n resource dependencies.\n\n Depending on the precise contents of <c><i>FfxFsr2DispatchDescription</i></c> a\n different number of render jobs might have previously been enqueued (for\n example if sharpening is toggled on and off).\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] commandList                         A pointer to a <c><i>FfxCommandList</i></c> structure.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2ExecuteGpuJobsFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        commandList: FfxCommandList,
    ) -> FfxErrorCode,
>;
#[doc = " Pass a string message\n\n Used for debug messages.\n\n @param [in] type                       The type of message.\n @param [in] message                    A string message to pass.\n\n\n @ingroup FSR2"]
pub type FfxFsr2Message =
    ::std::option::Option<unsafe extern "C" fn(type_: FfxFsr2MsgType, message: *const wchar_t)>;
#[doc = " A structure encapsulating the interface between the core implentation of\n the FSR2 algorithm and any graphics API that it should ultimately call.\n\n This set of functions serves as an abstraction layer between FSR2 and the\n API used to implement it. While FSR2 ships with backends for DirectX12 and\n Vulkan, it is possible to implement your own backend for other platforms or\n which sits ontop of your engine's own abstraction layer. For details on the\n expectations of what each function should do you should refer the\n description of the following function pointer types:\n\n     <c><i>FfxFsr2CreateDeviceFunc</i></c>\n     <c><i>FfxFsr2GetDeviceCapabilitiesFunc</i></c>\n     <c><i>FfxFsr2DestroyDeviceFunc</i></c>\n     <c><i>FfxFsr2CreateResourceFunc</i></c>\n     <c><i>FfxFsr2GetResourceDescriptionFunc</i></c>\n     <c><i>FfxFsr2DestroyResourceFunc</i></c>\n     <c><i>FfxFsr2CreatePipelineFunc</i></c>\n     <c><i>FfxFsr2DestroyPipelineFunc</i></c>\n     <c><i>FfxFsr2ScheduleGpuJobFunc</i></c>\n     <c><i>FfxFsr2ExecuteGpuJobsFunc</i></c>\n\n Depending on the graphics API that is abstracted by the backend, it may be\n required that the backend is to some extent stateful. To ensure that\n applications retain full control to manage the memory used by FSR2, the\n <c><i>scratchBuffer</i></c> and <c><i>scratchBufferSize</i></c> fields are\n provided. A backend should provide a means of specifying how much scratch\n memory is required for its internal implementation (e.g: via a function\n or constant value). The application is that responsible for allocating that\n memory and providing it when setting up the FSR2 backend. Backends provided\n with FSR2 do not perform dynamic memory allocations, and instead\n suballocate all memory from the scratch buffers provided.\n\n The <c><i>scratchBuffer</i></c> and <c><i>scratchBufferSize</i></c> fields\n should be populated according to the requirements of each backend. For\n example, if using the DirectX 12 backend you should call the\n <c><i>ffxFsr2GetScratchMemorySizeDX12</i></c> function. It is not required\n that custom backend implementations use a scratch buffer.\n\n @ingroup FSR2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxFsr2Interface {
    #[doc = "< A callback function to create and initialize the backend context."]
    pub fpCreateBackendContext: FfxFsr2CreateBackendContextFunc,
    #[doc = "< A callback function to query device capabilites."]
    pub fpGetDeviceCapabilities: FfxFsr2GetDeviceCapabilitiesFunc,
    #[doc = "< A callback function to destroy the backendcontext. This also dereferences the device."]
    pub fpDestroyBackendContext: FfxFsr2DestroyBackendContextFunc,
    #[doc = "< A callback function to create a resource."]
    pub fpCreateResource: FfxFsr2CreateResourceFunc,
    #[doc = "< A callback function to register an external resource."]
    pub fpRegisterResource: FfxFsr2RegisterResourceFunc,
    #[doc = "< A callback function to unregister external resource."]
    pub fpUnregisterResources: FfxFsr2UnregisterResourcesFunc,
    #[doc = "< A callback function to retrieve a resource description."]
    pub fpGetResourceDescription: FfxFsr2GetResourceDescriptionFunc,
    #[doc = "< A callback function to destroy a resource."]
    pub fpDestroyResource: FfxFsr2DestroyResourceFunc,
    #[doc = "< A callback function to create a render or compute pipeline."]
    pub fpCreatePipeline: FfxFsr2CreatePipelineFunc,
    #[doc = "< A callback function to destroy a render or compute pipeline."]
    pub fpDestroyPipeline: FfxFsr2DestroyPipelineFunc,
    #[doc = "< A callback function to schedule a render job."]
    pub fpScheduleGpuJob: FfxFsr2ScheduleGpuJobFunc,
    #[doc = "< A callback function to execute all queued render jobs."]
    pub fpExecuteGpuJobs: FfxFsr2ExecuteGpuJobsFunc,
    #[doc = "< A preallocated buffer for memory utilized internally by the backend."]
    pub scratchBuffer: *mut ::std::os::raw::c_void,
    #[doc = "< Size of the buffer pointed to by <c><i>scratchBuffer</i></c>."]
    pub scratchBufferSize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxFsr2Interface"][::std::mem::size_of::<FfxFsr2Interface>() - 112usize];
    ["Alignment of FfxFsr2Interface"][::std::mem::align_of::<FfxFsr2Interface>() - 8usize];
    ["Offset of field: FfxFsr2Interface::fpCreateBackendContext"]
        [::std::mem::offset_of!(FfxFsr2Interface, fpCreateBackendContext) - 0usize];
    ["Offset of field: FfxFsr2Interface::fpGetDeviceCapabilities"]
        [::std::mem::offset_of!(FfxFsr2Interface, fpGetDeviceCapabilities) - 8usize];
    ["Offset of field: FfxFsr2Interface::fpDestroyBackendContext"]
        [::std::mem::offset_of!(FfxFsr2Interface, fpDestroyBackendContext) - 16usize];
    ["Offset of field: FfxFsr2Interface::fpCreateResource"]
        [::std::mem::offset_of!(FfxFsr2Interface, fpCreateResource) - 24usize];
    ["Offset of field: FfxFsr2Interface::fpRegisterResource"]
        [::std::mem::offset_of!(FfxFsr2Interface, fpRegisterResource) - 32usize];
    ["Offset of field: FfxFsr2Interface::fpUnregisterResources"]
        [::std::mem::offset_of!(FfxFsr2Interface, fpUnregisterResources) - 40usize];
    ["Offset of field: FfxFsr2Interface::fpGetResourceDescription"]
        [::std::mem::offset_of!(FfxFsr2Interface, fpGetResourceDescription) - 48usize];
    ["Offset of field: FfxFsr2Interface::fpDestroyResource"]
        [::std::mem::offset_of!(FfxFsr2Interface, fpDestroyResource) - 56usize];
    ["Offset of field: FfxFsr2Interface::fpCreatePipeline"]
        [::std::mem::offset_of!(FfxFsr2Interface, fpCreatePipeline) - 64usize];
    ["Offset of field: FfxFsr2Interface::fpDestroyPipeline"]
        [::std::mem::offset_of!(FfxFsr2Interface, fpDestroyPipeline) - 72usize];
    ["Offset of field: FfxFsr2Interface::fpScheduleGpuJob"]
        [::std::mem::offset_of!(FfxFsr2Interface, fpScheduleGpuJob) - 80usize];
    ["Offset of field: FfxFsr2Interface::fpExecuteGpuJobs"]
        [::std::mem::offset_of!(FfxFsr2Interface, fpExecuteGpuJobs) - 88usize];
    ["Offset of field: FfxFsr2Interface::scratchBuffer"]
        [::std::mem::offset_of!(FfxFsr2Interface, scratchBuffer) - 96usize];
    ["Offset of field: FfxFsr2Interface::scratchBufferSize"]
        [::std::mem::offset_of!(FfxFsr2Interface, scratchBufferSize) - 104usize];
};
pub const FfxFsr2QualityMode_FFX_FSR2_QUALITY_MODE_QUALITY: FfxFsr2QualityMode = 1;
pub const FfxFsr2QualityMode_FFX_FSR2_QUALITY_MODE_BALANCED: FfxFsr2QualityMode = 2;
pub const FfxFsr2QualityMode_FFX_FSR2_QUALITY_MODE_PERFORMANCE: FfxFsr2QualityMode = 3;
pub const FfxFsr2QualityMode_FFX_FSR2_QUALITY_MODE_ULTRA_PERFORMANCE: FfxFsr2QualityMode = 4;
#[doc = " An enumeration of all the quality modes supported by FidelityFX Super\n Resolution 2 upscaling.\n\n In order to provide a consistent user experience across multiple\n applications which implement FSR2. It is strongly recommended that the\n following preset scaling factors are made available through your\n application's user interface.\n\n If your application does not expose the notion of preset scaling factors\n for upscaling algorithms (perhaps instead implementing a fixed ratio which\n is immutable) or implementing a more dynamic scaling scheme (such as\n dynamic resolution scaling), then there is no need to use these presets.\n\n Please note that <c><i>FFX_FSR2_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> is\n an optional mode which may introduce significant quality degradation in the\n final image. As such it is recommended that you evaluate the final results\n of using this scaling mode before deciding if you should include it in your\n application.\n\n @ingroup FSR2"]
pub type FfxFsr2QualityMode = ::std::os::raw::c_uint;
pub const FfxFsr2InitializationFlagBits_FFX_FSR2_ENABLE_HIGH_DYNAMIC_RANGE:
    FfxFsr2InitializationFlagBits = 1;
pub const FfxFsr2InitializationFlagBits_FFX_FSR2_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS:
    FfxFsr2InitializationFlagBits = 2;
pub const FfxFsr2InitializationFlagBits_FFX_FSR2_ENABLE_MOTION_VECTORS_JITTER_CANCELLATION:
    FfxFsr2InitializationFlagBits = 4;
pub const FfxFsr2InitializationFlagBits_FFX_FSR2_ENABLE_DEPTH_INVERTED:
    FfxFsr2InitializationFlagBits = 8;
pub const FfxFsr2InitializationFlagBits_FFX_FSR2_ENABLE_DEPTH_INFINITE:
    FfxFsr2InitializationFlagBits = 16;
pub const FfxFsr2InitializationFlagBits_FFX_FSR2_ENABLE_AUTO_EXPOSURE:
    FfxFsr2InitializationFlagBits = 32;
pub const FfxFsr2InitializationFlagBits_FFX_FSR2_ENABLE_DYNAMIC_RESOLUTION:
    FfxFsr2InitializationFlagBits = 64;
pub const FfxFsr2InitializationFlagBits_FFX_FSR2_ENABLE_TEXTURE1D_USAGE:
    FfxFsr2InitializationFlagBits = 128;
pub const FfxFsr2InitializationFlagBits_FFX_FSR2_ENABLE_DEBUG_CHECKING:
    FfxFsr2InitializationFlagBits = 256;
#[doc = " An enumeration of bit flags used when creating a\n <c><i>FfxFsr2Context</i></c>. See <c><i>FfxFsr2ContextDescription</i></c>.\n\n @ingroup FSR2"]
pub type FfxFsr2InitializationFlagBits = ::std::os::raw::c_uint;
#[doc = " A structure encapsulating the parameters required to initialize FidelityFX\n Super Resolution 2 upscaling.\n\n @ingroup FSR2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxFsr2ContextDescription {
    #[doc = "< A collection of <c><i>FfxFsr2InitializationFlagBits</i></c>."]
    pub flags: u32,
    #[doc = "< The maximum size that rendering will be performed at."]
    pub maxRenderSize: FfxDimensions2D,
    #[doc = "< The size of the presentation resolution\n< targeted by the upscaling process."]
    pub displaySize: FfxDimensions2D,
    #[doc = "< A set of pointers to the backend\n< implementation for FSR 2.0."]
    pub callbacks: FfxFsr2Interface,
    #[doc = "< The abstracted device which is passed to some callback\n< functions."]
    pub device: FfxDevice,
    #[doc = "< A pointer to a function that can recieve\n< messages from the runtime."]
    pub fpMessage: FfxFsr2Message,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxFsr2ContextDescription"]
        [::std::mem::size_of::<FfxFsr2ContextDescription>() - 152usize];
    ["Alignment of FfxFsr2ContextDescription"]
        [::std::mem::align_of::<FfxFsr2ContextDescription>() - 8usize];
    ["Offset of field: FfxFsr2ContextDescription::flags"]
        [::std::mem::offset_of!(FfxFsr2ContextDescription, flags) - 0usize];
    ["Offset of field: FfxFsr2ContextDescription::maxRenderSize"]
        [::std::mem::offset_of!(FfxFsr2ContextDescription, maxRenderSize) - 4usize];
    ["Offset of field: FfxFsr2ContextDescription::displaySize"]
        [::std::mem::offset_of!(FfxFsr2ContextDescription, displaySize) - 12usize];
    ["Offset of field: FfxFsr2ContextDescription::callbacks"]
        [::std::mem::offset_of!(FfxFsr2ContextDescription, callbacks) - 24usize];
    ["Offset of field: FfxFsr2ContextDescription::device"]
        [::std::mem::offset_of!(FfxFsr2ContextDescription, device) - 136usize];
    ["Offset of field: FfxFsr2ContextDescription::fpMessage"]
        [::std::mem::offset_of!(FfxFsr2ContextDescription, fpMessage) - 144usize];
};
#[doc = " A structure encapsulating the parameters for dispatching the various passes\n of FidelityFX Super Resolution 2.\n\n @ingroup FSR2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxFsr2DispatchDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record\n< FSR2 rendering commands into."]
    pub commandList: FfxCommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the color\n< buffer for the current frame (at render resolution)."]
    pub color: FfxResource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 32bit depth\n< values for the current frame (at render resolution)."]
    pub depth: FfxResource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 2-dimensional\n< motion vectors (at render resolution if\n< <c><i>FFX_FSR2_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS</i></c>\n< is not set)."]
    pub motionVectors: FfxResource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing a\n< 1x1 exposure value."]
    pub exposure: FfxResource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing\n< alpha value of reactive objects in the scene."]
    pub reactive: FfxResource,
    #[doc = "< A optional <c><i>FfxResource</i></c>\n< containing alpha value of special objects\n< in the scene."]
    pub transparencyAndComposition: FfxResource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output color\n< buffer for the current frame (at presentation resolution)."]
    pub output: FfxResource,
    #[doc = "< The subpixel jitter offset applied to the camera."]
    pub jitterOffset: FfxFloatCoords2D,
    #[doc = "< The scale factor to apply to motion vectors."]
    pub motionVectorScale: FfxFloatCoords2D,
    #[doc = "< The resolution that was used for rendering\n< the input resources."]
    pub renderSize: FfxDimensions2D,
    #[doc = "< Enable an additional sharpening pass."]
    pub enableSharpening: bool,
    #[doc = "< The sharpness value between 0 and 1, where 0 is no\n< additional sharpness and 1 is maximum additional\n< sharpness."]
    pub sharpness: f32,
    #[doc = "< The time elapsed since the last frame (expressed in\n< milliseconds)."]
    pub frameTimeDelta: f32,
    #[doc = "< The pre exposure value (must be > 0.0f)"]
    pub preExposure: f32,
    #[doc = "< A boolean value which when set to true, indicates the camera\n< has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The distance to the near plane of the camera."]
    pub cameraNear: f32,
    #[doc = "< The distance to the far plane of the camera. This is\n< used only used in case of non infinite depth."]
    pub cameraFar: f32,
    #[doc = "< The camera angle field of view in the\n< vertical direction (expressed in radians)."]
    pub cameraFovAngleVertical: f32,
    #[doc = "< The scale factor to convert view space\n< units to meters"]
    pub viewSpaceToMetersFactor: f32,
    #[doc = "< A boolean value to indicate internal reactive\n< autogeneration should be used"]
    pub enableAutoReactive: bool,
    #[doc = "< A <c><i>FfxResource</i></c> containing the\n< opaque only color buffer for the current\n< frame (at render resolution)."]
    pub colorOpaqueOnly: FfxResource,
    #[doc = "< Cutoff value for TC"]
    pub autoTcThreshold: f32,
    #[doc = "< A value to scale the transparency and composition mask"]
    pub autoTcScale: f32,
    #[doc = "< A value to scale the reactive mask"]
    pub autoReactiveScale: f32,
    #[doc = "< A value to clamp the reactive mask"]
    pub autoReactiveMax: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxFsr2DispatchDescription"]
        [::std::mem::size_of::<FfxFsr2DispatchDescription>() - 2584usize];
    ["Alignment of FfxFsr2DispatchDescription"]
        [::std::mem::align_of::<FfxFsr2DispatchDescription>() - 8usize];
    ["Offset of field: FfxFsr2DispatchDescription::commandList"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, commandList) - 0usize];
    ["Offset of field: FfxFsr2DispatchDescription::color"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, color) - 8usize];
    ["Offset of field: FfxFsr2DispatchDescription::depth"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, depth) - 320usize];
    ["Offset of field: FfxFsr2DispatchDescription::motionVectors"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, motionVectors) - 632usize];
    ["Offset of field: FfxFsr2DispatchDescription::exposure"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, exposure) - 944usize];
    ["Offset of field: FfxFsr2DispatchDescription::reactive"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, reactive) - 1256usize];
    ["Offset of field: FfxFsr2DispatchDescription::transparencyAndComposition"][::std::mem::offset_of!(
        FfxFsr2DispatchDescription,
        transparencyAndComposition
    ) - 1568usize];
    ["Offset of field: FfxFsr2DispatchDescription::output"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, output) - 1880usize];
    ["Offset of field: FfxFsr2DispatchDescription::jitterOffset"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, jitterOffset) - 2192usize];
    ["Offset of field: FfxFsr2DispatchDescription::motionVectorScale"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, motionVectorScale) - 2200usize];
    ["Offset of field: FfxFsr2DispatchDescription::renderSize"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, renderSize) - 2208usize];
    ["Offset of field: FfxFsr2DispatchDescription::enableSharpening"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, enableSharpening) - 2216usize];
    ["Offset of field: FfxFsr2DispatchDescription::sharpness"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, sharpness) - 2220usize];
    ["Offset of field: FfxFsr2DispatchDescription::frameTimeDelta"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, frameTimeDelta) - 2224usize];
    ["Offset of field: FfxFsr2DispatchDescription::preExposure"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, preExposure) - 2228usize];
    ["Offset of field: FfxFsr2DispatchDescription::reset"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, reset) - 2232usize];
    ["Offset of field: FfxFsr2DispatchDescription::cameraNear"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, cameraNear) - 2236usize];
    ["Offset of field: FfxFsr2DispatchDescription::cameraFar"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, cameraFar) - 2240usize];
    ["Offset of field: FfxFsr2DispatchDescription::cameraFovAngleVertical"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, cameraFovAngleVertical) - 2244usize];
    ["Offset of field: FfxFsr2DispatchDescription::viewSpaceToMetersFactor"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, viewSpaceToMetersFactor) - 2248usize];
    ["Offset of field: FfxFsr2DispatchDescription::enableAutoReactive"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, enableAutoReactive) - 2252usize];
    ["Offset of field: FfxFsr2DispatchDescription::colorOpaqueOnly"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, colorOpaqueOnly) - 2256usize];
    ["Offset of field: FfxFsr2DispatchDescription::autoTcThreshold"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, autoTcThreshold) - 2568usize];
    ["Offset of field: FfxFsr2DispatchDescription::autoTcScale"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, autoTcScale) - 2572usize];
    ["Offset of field: FfxFsr2DispatchDescription::autoReactiveScale"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, autoReactiveScale) - 2576usize];
    ["Offset of field: FfxFsr2DispatchDescription::autoReactiveMax"]
        [::std::mem::offset_of!(FfxFsr2DispatchDescription, autoReactiveMax) - 2580usize];
};
#[doc = " A structure encapsulating the parameters for automatic generation of a\n reactive mask\n\n @ingroup FSR2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxFsr2GenerateReactiveDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record\n< FSR2 rendering commands into."]
    pub commandList: FfxCommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the\n< opaque only color buffer for the current\n< frame (at render resolution)."]
    pub colorOpaqueOnly: FfxResource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the\n< opaque+translucent color buffer for the\n< current frame (at render resolution)."]
    pub colorPreUpscale: FfxResource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the\n< surface to generate the reactive mask into."]
    pub outReactive: FfxResource,
    #[doc = "< The resolution that was used for rendering\n< the input resources."]
    pub renderSize: FfxDimensions2D,
    #[doc = "< A value to scale the output"]
    pub scale: f32,
    #[doc = "< A threshold value to generate a binary reactive mask"]
    pub cutoffThreshold: f32,
    #[doc = "< A value to set for the binary reactive mask"]
    pub binaryValue: f32,
    #[doc = "< Flags to determine how to generate the reactive mask"]
    pub flags: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxFsr2GenerateReactiveDescription"]
        [::std::mem::size_of::<FfxFsr2GenerateReactiveDescription>() - 968usize];
    ["Alignment of FfxFsr2GenerateReactiveDescription"]
        [::std::mem::align_of::<FfxFsr2GenerateReactiveDescription>() - 8usize];
    ["Offset of field: FfxFsr2GenerateReactiveDescription::commandList"]
        [::std::mem::offset_of!(FfxFsr2GenerateReactiveDescription, commandList) - 0usize];
    ["Offset of field: FfxFsr2GenerateReactiveDescription::colorOpaqueOnly"]
        [::std::mem::offset_of!(FfxFsr2GenerateReactiveDescription, colorOpaqueOnly) - 8usize];
    ["Offset of field: FfxFsr2GenerateReactiveDescription::colorPreUpscale"]
        [::std::mem::offset_of!(FfxFsr2GenerateReactiveDescription, colorPreUpscale) - 320usize];
    ["Offset of field: FfxFsr2GenerateReactiveDescription::outReactive"]
        [::std::mem::offset_of!(FfxFsr2GenerateReactiveDescription, outReactive) - 632usize];
    ["Offset of field: FfxFsr2GenerateReactiveDescription::renderSize"]
        [::std::mem::offset_of!(FfxFsr2GenerateReactiveDescription, renderSize) - 944usize];
    ["Offset of field: FfxFsr2GenerateReactiveDescription::scale"]
        [::std::mem::offset_of!(FfxFsr2GenerateReactiveDescription, scale) - 952usize];
    ["Offset of field: FfxFsr2GenerateReactiveDescription::cutoffThreshold"]
        [::std::mem::offset_of!(FfxFsr2GenerateReactiveDescription, cutoffThreshold) - 956usize];
    ["Offset of field: FfxFsr2GenerateReactiveDescription::binaryValue"]
        [::std::mem::offset_of!(FfxFsr2GenerateReactiveDescription, binaryValue) - 960usize];
    ["Offset of field: FfxFsr2GenerateReactiveDescription::flags"]
        [::std::mem::offset_of!(FfxFsr2GenerateReactiveDescription, flags) - 964usize];
};
#[doc = " A structure encapsulating the FidelityFX Super Resolution 2 context.\n\n This sets up an object which contains all persistent internal data and\n resources that are required by FSR2.\n\n The <c><i>FfxFsr2Context</i></c> object should have a lifetime matching\n your use of FSR2. Before destroying the FSR2 context care should be taken\n to ensure the GPU is not accessing the resources created or used by FSR2.\n It is therefore recommended that the GPU is idle before destroying the\n FSR2 context.\n\n @ingroup FSR2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxFsr2Context {
    #[doc = "< An opaque set of <c>uint32_t</c> which\n< contain the data for the context."]
    pub data: [u32; 16536usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FfxFsr2Context"][::std::mem::size_of::<FfxFsr2Context>() - 66144usize];
    ["Alignment of FfxFsr2Context"][::std::mem::align_of::<FfxFsr2Context>() - 4usize];
    ["Offset of field: FfxFsr2Context::data"]
        [::std::mem::offset_of!(FfxFsr2Context, data) - 0usize];
};
extern "C" {
    #[doc = " Create a FidelityFX Super Resolution 2 context from the parameters\n programmed to the <c><i>FfxFsr2CreateParams</i></c> structure.\n\n The context structure is the main object used to interact with the FSR2\n API, and is responsible for the management of the internal resources used\n by the FSR2 algorithm. When this API is called, multiple calls will be\n made via the pointers contained in the <c><i>callbacks</i></c> structure.\n These callbacks will attempt to retreive the device capabilities, and\n create the internal resources, and pipelines required by FSR2's\n frame-to-frame function. Depending on the precise configuration used when\n creating the <c><i>FfxFsr2Context</i></c> a different set of resources and\n pipelines might be requested via the callback functions.\n\n The flags included in the <c><i>flags</i></c> field of\n <c><i>FfxFsr2Context</i></c> how match the configuration of your\n application as well as the intended use of FSR2. It is important that these\n flags are set correctly (as well as a correct programmed\n <c><i>FfxFsr2DispatchDescription</i></c>) to ensure correct operation. It is\n recommended to consult the overview documentation for further details on\n how FSR2 should be integerated into an application.\n\n When the <c><i>FfxFsr2Context</i></c> is created, you should use the\n <c><i>ffxFsr2ContextDispatch</i></c> function each frame where FSR2\n upscaling should be applied. See the documentation of\n <c><i>ffxFsr2ContextDispatch</i></c> for more details.\n\n The <c><i>FfxFsr2Context</i></c> should be destroyed when use of it is\n completed, typically when an application is unloaded or FSR2 upscaling is\n disabled by a user. To destroy the FSR2 context you should call\n <c><i>ffxFsr2ContextDestroy</i></c>.\n\n @param [out] context                A pointer to a\n <c><i>FfxFsr2Context</i></c> structure to populate.\n @param [in]  contextDescription     A pointer to a\n <c><i>FfxFsr2ContextDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either\n <c><i>context</i></c> or <c><i>contextDescription</i></c> was\n <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_INCOMPLETE_INTERFACE      The operation failed because the\n <c><i>FfxFsr2ContextDescription.callbacks</i></c>  was not fully specified.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error\n returned from the backend.\n\n @ingroup FSR2"]
    pub fn ffxFsr2ContextCreate(
        context: *mut FfxFsr2Context,
        contextDescription: *const FfxFsr2ContextDescription,
    ) -> FfxErrorCode;
}
extern "C" {
    #[doc = " Dispatch the various passes that constitute FidelityFX Super Resolution 2.\n\n FSR2 is a composite effect, meaning that it is compromised of multiple\n constituent passes (implemented as one or more clears, copies and compute\n dispatches). The <c><i>ffxFsr2ContextDispatch</i></c> function is the\n function which (via the use of the functions contained in the\n <c><i>callbacks</i></c> field of the <c><i>FfxFsr2Context</i></c>\n structure) utlimately generates the sequence of graphics API calls required\n each frame.\n\n As with the creation of the <c><i>FfxFsr2Context</i></c> correctly\n programming the <c><i>FfxFsr2DispatchDescription</i></c> is key to ensuring\n the correct operation of FSR2. It is particularly important to ensure that\n camera jitter is correctly applied to your application's projection matrix\n (or camera origin for raytraced applications). FSR2 provides the\n <c><i>ffxFsr2GetJitterPhaseCount</i></c> and\n <c><i>ffxFsr2GetJitterOffset</i></c> entry points to help applications\n correctly compute the camera jitter. Whatever jitter pattern is used by the\n application it should be correctly programmed to the\n <c><i>jitterOffset</i></c> field of the <c><i>dispatchDescription</i></c>\n structure. For more guidance on camera jitter please consult the\n documentation for <c><i>ffxFsr2GetJitterOffset</i></c> as well as the\n accompanying overview documentation for FSR2.\n\n @param [in] context                 A pointer to a\n <c><i>FfxFsr2Context</i></c> structure.\n @param [in] dispatchDescription     A pointer to a\n <c><i>FfxFsr2DispatchDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either\n <c><i>context</i></c> or <c><i>dispatchDescription</i></c> was\n <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_OUT_OF_RANGE              The operation failed because\n <c><i>dispatchDescription.renderSize</i></c> was larger than the maximum\n render resolution.\n @retval\n FFX_ERROR_NULL_DEVICE               The operation failed because the device\n inside the context was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error\n returned from the backend.\n\n @ingroup FSR2"]
    pub fn ffxFsr2ContextDispatch(
        context: *mut FfxFsr2Context,
        dispatchDescription: *const FfxFsr2DispatchDescription,
    ) -> FfxErrorCode;
}
extern "C" {
    #[doc = " A helper function generate a Reactive mask from an opaque only texure and\n one containing translucent objects.\n\n @param [in] context                 A pointer to a\n <c><i>FfxFsr2Context</i></c> structure.\n @param [in] params                  A pointer to a\n <c><i>FfxFsr2GenerateReactiveDescription</i></c> structure\n\n @retval\n FFX_OK                              The operation completed successfully.\n\n @ingroup FSR2"]
    pub fn ffxFsr2ContextGenerateReactiveMask(
        context: *mut FfxFsr2Context,
        params: *const FfxFsr2GenerateReactiveDescription,
    ) -> FfxErrorCode;
}
extern "C" {
    #[doc = " Destroy the FidelityFX Super Resolution context.\n\n @param [out] context                A pointer to a\n <c><i>FfxFsr2Context</i></c> structure to destroy.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either\n <c><i>context</i></c> was <c><i>NULL</i></c>.\n\n @ingroup FSR2"]
    pub fn ffxFsr2ContextDestroy(context: *mut FfxFsr2Context) -> FfxErrorCode;
}
extern "C" {
    #[doc = " Get the upscale ratio from the quality mode.\n\n The following table enumerates the mapping of the quality modes to\n per-dimension scaling ratios.\n\n Quality preset                                        | Scale factor\n ----------------------------------------------------- | -------------\n <c><i>FFX_FSR2_QUALITY_MODE_QUALITY</i></c>           | 1.5x\n <c><i>FFX_FSR2_QUALITY_MODE_BALANCED</i></c>          | 1.7x\n <c><i>FFX_FSR2_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x\n <c><i>FFX_FSR2_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x\n\n Passing an invalid <c><i>qualityMode</i></c> will return 0.0f.\n\n @param [in] qualityMode             The quality mode preset.\n\n @returns\n The upscaling the per-dimension upscaling ratio for\n <c><i>qualityMode</i></c> according to the table above.\n\n @ingroup FSR2"]
    pub fn ffxFsr2GetUpscaleRatioFromQualityMode(qualityMode: FfxFsr2QualityMode) -> f32;
}
extern "C" {
    #[doc = " A helper function to calculate the rendering resolution from a target\n resolution and desired quality level.\n\n This function applies the scaling factor returned by\n <c><i>ffxFsr2GetUpscaleRatioFromQualityMode</i></c> to each dimension.\n\n @param [out] renderWidth            A pointer to a <c>uint32_t</c> which\n will hold the calculated render resolution width.\n @param [out] renderHeight           A pointer to a <c>uint32_t</c> which\n will hold the calculated render resolution height.\n @param [in] displayWidth            The target display resolution width.\n @param [in] displayHeight           The target display resolution height.\n @param [in] qualityMode             The desired quality mode for FSR 2\n upscaling.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>renderWidth</i></c> or\n <c><i>renderHeight</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ENUM              An invalid quality mode was specified.\n\n @ingroup FSR2"]
    pub fn ffxFsr2GetRenderResolutionFromQualityMode(
        renderWidth: *mut u32,
        renderHeight: *mut u32,
        displayWidth: u32,
        displayHeight: u32,
        qualityMode: FfxFsr2QualityMode,
    ) -> FfxErrorCode;
}
extern "C" {
    #[doc = " A helper function to calculate the jitter phase count from display\n resolution.\n\n For more detailed information about the application of camera jitter to\n your application's rendering please refer to the\n <c><i>ffxFsr2GetJitterOffset</i></c> function.\n\n The table below shows the jitter phase count which this function\n would return for each of the quality presets.\n\n Quality preset                                        | Scale factor  |\n Phase count\n ----------------------------------------------------- | ------------- |\n --------------- <c><i>FFX_FSR2_QUALITY_MODE_QUALITY</i></c>           | 1.5x\n | 18 <c><i>FFX_FSR2_QUALITY_MODE_BALANCED</i></c>          | 1.7x          |\n 23 <c><i>FFX_FSR2_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x          |\n 32 <c><i>FFX_FSR2_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x          |\n 72 Custom                                                | [1..n]x       |\n ceil(8*n^2)\n\n @param [in] renderWidth             The render resolution width.\n @param [in] displayWidth            The display resolution width.\n\n @returns\n The jitter phase count for the scaling factor between\n <c><i>renderWidth</i></c> and <c><i>displayWidth</i></c>.\n\n @ingroup FSR2"]
    pub fn ffxFsr2GetJitterPhaseCount(renderWidth: i32, displayWidth: i32) -> i32;
}
extern "C" {
    #[doc = " A helper function to calculate the subpixel jitter offset.\n\n FSR2 relies on the application to apply sub-pixel jittering while rendering.\n This is typically included in the projection matrix of the camera. To make\n the application of camera jitter simple, the FSR2 API provides a small set\n of utility function which computes the sub-pixel jitter offset for a\n particular frame within a sequence of separate jitter offsets. To begin, the\n index within the jitter phase must be computed. To calculate the\n sequence's length, you can call the <c><i>ffxFsr2GetJitterPhaseCount</i></c>\n function. The index should be a value which is incremented each frame modulo\n the length of the sequence computed by\n <c><i>ffxFsr2GetJitterPhaseCount</i></c>. The index within the jitter phase\n is passed to <c><i>ffxFsr2GetJitterOffset</i></c> via the\n <c><i>index</i></c> parameter.\n\n This function uses a Halton(2,3) sequence to compute the jitter offset.\n The ultimate index used for the sequence is <c><i>index</i></c> %\n <c><i>phaseCount</i></c>.\n\n It is important to understand that the values returned from the\n <c><i>ffxFsr2GetJitterOffset</i></c> function are in unit pixel space, and\n in order to composite this correctly into a projection matrix we must\n convert them into projection offsets. This is done as per the pseudo code\n listing which is shown below.\n\n     const int32_t jitterPhaseCount = ffxFsr2GetJitterPhaseCount(renderWidth,\n     displayWidth);\n\n     float jitterX = 0;\n     float jitterY = 0;\n     ffxFsr2GetJitterOffset(&jitterX, &jitterY, index, jitterPhaseCount);\n\n     const float jitterX = 2.0f * jitterX / (float)renderWidth;\n     const float jitterY = -2.0f * jitterY / (float)renderHeight;\n     const Matrix4 jitterTranslationMatrix =\n     translateMatrix(Matrix3::identity, Vector3(jitterX, jitterY, 0)); const\n     Matrix4 jitteredProjectionMatrix = jitterTranslationMatrix *\n     projectionMatrix;\n\n Jitter should be applied to all rendering. This includes opaque, alpha\n transparent, and raytraced objects. For rasterized objects, the sub-pixel\n jittering values calculated by the <c><i>iffxFsr2GetJitterOffset</i></c>\n function can be applied to the camera projection matrix which is ultimately\n used to perform transformations during vertex shading. For raytraced\n rendering, the sub-pixel jitter should be applied to the ray's origin,\n often the camera's position.\n\n Whether you elect to use the <c><i>ffxFsr2GetJitterOffset</i></c> function\n or your own sequence generator, you must program the\n <c><i>jitterOffset</i></c> field of the\n <c><i>FfxFsr2DispatchParameters</i></c> structure in order to inform FSR2\n of the jitter offset that has been applied in order to render each frame.\n\n If not using the recommended <c><i>ffxFsr2GetJitterOffset</i></c> function,\n care should be taken that your jitter sequence never generates a null\n vector; that is value of 0 in both the X and Y dimensions.\n\n @param [out] outX                   A pointer to a <c>float</c> which will\n contain the subpixel jitter offset for the x dimension.\n @param [out] outY                   A pointer to a <c>float</c> which will\n contain the subpixel jitter offset for the y dimension.\n @param [in] index                   The index within the jitter sequence.\n @param [in] phaseCount              The length of jitter phase. See\n <c><i>ffxFsr2GetJitterPhaseCount</i></c>.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>outX</i></c> or\n <c><i>outY</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ARGUMENT          Argument <c><i>phaseCount</i></c> must\n be greater than 0.\n\n @ingroup FSR2"]
    pub fn ffxFsr2GetJitterOffset(
        outX: *mut f32,
        outY: *mut f32,
        index: i32,
        phaseCount: i32,
    ) -> FfxErrorCode;
}
extern "C" {
    #[doc = " A helper function to check if a resource is\n <c><i>FFX_FSR2_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @param [in] resource                A <c><i>FfxResource</i></c>.\n\n @returns\n true                                The <c><i>resource</i></c> was not\n <c><i>FFX_FSR2_RESOURCE_IDENTIFIER_NULL</i></c>.\n @returns\n false                               The <c><i>resource</i></c> was\n <c><i>FFX_FSR2_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @ingroup FSR2"]
    pub fn ffxFsr2ResourceIsNull(resource: FfxResource) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBuffer_T {
    _unused: [u8; 0],
}
pub type VkBuffer = *mut VkBuffer_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImage_T {
    _unused: [u8; 0],
}
pub type VkImage = *mut VkImage_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevice_T {
    _unused: [u8; 0],
}
pub type VkPhysicalDevice = *mut VkPhysicalDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDevice_T {
    _unused: [u8; 0],
}
pub type VkDevice = *mut VkDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBuffer_T {
    _unused: [u8; 0],
}
pub type VkCommandBuffer = *mut VkCommandBuffer_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageView_T {
    _unused: [u8; 0],
}
pub type VkImageView = *mut VkImageView_T;
pub const VkImageLayout_VK_IMAGE_LAYOUT_UNDEFINED: VkImageLayout = 0;
pub const VkImageLayout_VK_IMAGE_LAYOUT_GENERAL: VkImageLayout = 1;
pub const VkImageLayout_VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: VkImageLayout = 2;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout = 3;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout = 4;
pub const VkImageLayout_VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: VkImageLayout = 5;
pub const VkImageLayout_VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: VkImageLayout = 6;
pub const VkImageLayout_VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: VkImageLayout = 7;
pub const VkImageLayout_VK_IMAGE_LAYOUT_PREINITIALIZED: VkImageLayout = 8;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout =
    1000117000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout =
    1000117001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL: VkImageLayout = 1000241000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL: VkImageLayout = 1000241001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout = 1000241002;
pub const VkImageLayout_VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout = 1000241003;
pub const VkImageLayout_VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL: VkImageLayout = 1000314000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL: VkImageLayout = 1000314001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ: VkImageLayout = 1000232000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: VkImageLayout = 1000001002;
pub const VkImageLayout_VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR: VkImageLayout = 1000024000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR: VkImageLayout = 1000024001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR: VkImageLayout = 1000024002;
pub const VkImageLayout_VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR: VkImageLayout = 1000111000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT: VkImageLayout =
    1000218000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR:
    VkImageLayout = 1000164003;
pub const VkImageLayout_VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR: VkImageLayout = 1000299000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR: VkImageLayout = 1000299001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR: VkImageLayout = 1000299002;
pub const VkImageLayout_VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT: VkImageLayout =
    1000339000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR: VkImageLayout =
    1000553000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR:
    VkImageLayout = 1000117000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR:
    VkImageLayout = 1000117001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV: VkImageLayout = 1000164003;
pub const VkImageLayout_VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR: VkImageLayout = 1000232000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = 1000241000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR: VkImageLayout = 1000241001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = 1000241002;
pub const VkImageLayout_VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR: VkImageLayout = 1000241003;
pub const VkImageLayout_VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR: VkImageLayout = 1000314000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = 1000314001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_MAX_ENUM: VkImageLayout = 2147483647;
pub type VkImageLayout = ::std::os::raw::c_uint;
pub const VkFormat_VK_FORMAT_UNDEFINED: VkFormat = 0;
pub const VkFormat_VK_FORMAT_R4G4_UNORM_PACK8: VkFormat = 1;
pub const VkFormat_VK_FORMAT_R4G4B4A4_UNORM_PACK16: VkFormat = 2;
pub const VkFormat_VK_FORMAT_B4G4R4A4_UNORM_PACK16: VkFormat = 3;
pub const VkFormat_VK_FORMAT_R5G6B5_UNORM_PACK16: VkFormat = 4;
pub const VkFormat_VK_FORMAT_B5G6R5_UNORM_PACK16: VkFormat = 5;
pub const VkFormat_VK_FORMAT_R5G5B5A1_UNORM_PACK16: VkFormat = 6;
pub const VkFormat_VK_FORMAT_B5G5R5A1_UNORM_PACK16: VkFormat = 7;
pub const VkFormat_VK_FORMAT_A1R5G5B5_UNORM_PACK16: VkFormat = 8;
pub const VkFormat_VK_FORMAT_R8_UNORM: VkFormat = 9;
pub const VkFormat_VK_FORMAT_R8_SNORM: VkFormat = 10;
pub const VkFormat_VK_FORMAT_R8_USCALED: VkFormat = 11;
pub const VkFormat_VK_FORMAT_R8_SSCALED: VkFormat = 12;
pub const VkFormat_VK_FORMAT_R8_UINT: VkFormat = 13;
pub const VkFormat_VK_FORMAT_R8_SINT: VkFormat = 14;
pub const VkFormat_VK_FORMAT_R8_SRGB: VkFormat = 15;
pub const VkFormat_VK_FORMAT_R8G8_UNORM: VkFormat = 16;
pub const VkFormat_VK_FORMAT_R8G8_SNORM: VkFormat = 17;
pub const VkFormat_VK_FORMAT_R8G8_USCALED: VkFormat = 18;
pub const VkFormat_VK_FORMAT_R8G8_SSCALED: VkFormat = 19;
pub const VkFormat_VK_FORMAT_R8G8_UINT: VkFormat = 20;
pub const VkFormat_VK_FORMAT_R8G8_SINT: VkFormat = 21;
pub const VkFormat_VK_FORMAT_R8G8_SRGB: VkFormat = 22;
pub const VkFormat_VK_FORMAT_R8G8B8_UNORM: VkFormat = 23;
pub const VkFormat_VK_FORMAT_R8G8B8_SNORM: VkFormat = 24;
pub const VkFormat_VK_FORMAT_R8G8B8_USCALED: VkFormat = 25;
pub const VkFormat_VK_FORMAT_R8G8B8_SSCALED: VkFormat = 26;
pub const VkFormat_VK_FORMAT_R8G8B8_UINT: VkFormat = 27;
pub const VkFormat_VK_FORMAT_R8G8B8_SINT: VkFormat = 28;
pub const VkFormat_VK_FORMAT_R8G8B8_SRGB: VkFormat = 29;
pub const VkFormat_VK_FORMAT_B8G8R8_UNORM: VkFormat = 30;
pub const VkFormat_VK_FORMAT_B8G8R8_SNORM: VkFormat = 31;
pub const VkFormat_VK_FORMAT_B8G8R8_USCALED: VkFormat = 32;
pub const VkFormat_VK_FORMAT_B8G8R8_SSCALED: VkFormat = 33;
pub const VkFormat_VK_FORMAT_B8G8R8_UINT: VkFormat = 34;
pub const VkFormat_VK_FORMAT_B8G8R8_SINT: VkFormat = 35;
pub const VkFormat_VK_FORMAT_B8G8R8_SRGB: VkFormat = 36;
pub const VkFormat_VK_FORMAT_R8G8B8A8_UNORM: VkFormat = 37;
pub const VkFormat_VK_FORMAT_R8G8B8A8_SNORM: VkFormat = 38;
pub const VkFormat_VK_FORMAT_R8G8B8A8_USCALED: VkFormat = 39;
pub const VkFormat_VK_FORMAT_R8G8B8A8_SSCALED: VkFormat = 40;
pub const VkFormat_VK_FORMAT_R8G8B8A8_UINT: VkFormat = 41;
pub const VkFormat_VK_FORMAT_R8G8B8A8_SINT: VkFormat = 42;
pub const VkFormat_VK_FORMAT_R8G8B8A8_SRGB: VkFormat = 43;
pub const VkFormat_VK_FORMAT_B8G8R8A8_UNORM: VkFormat = 44;
pub const VkFormat_VK_FORMAT_B8G8R8A8_SNORM: VkFormat = 45;
pub const VkFormat_VK_FORMAT_B8G8R8A8_USCALED: VkFormat = 46;
pub const VkFormat_VK_FORMAT_B8G8R8A8_SSCALED: VkFormat = 47;
pub const VkFormat_VK_FORMAT_B8G8R8A8_UINT: VkFormat = 48;
pub const VkFormat_VK_FORMAT_B8G8R8A8_SINT: VkFormat = 49;
pub const VkFormat_VK_FORMAT_B8G8R8A8_SRGB: VkFormat = 50;
pub const VkFormat_VK_FORMAT_A8B8G8R8_UNORM_PACK32: VkFormat = 51;
pub const VkFormat_VK_FORMAT_A8B8G8R8_SNORM_PACK32: VkFormat = 52;
pub const VkFormat_VK_FORMAT_A8B8G8R8_USCALED_PACK32: VkFormat = 53;
pub const VkFormat_VK_FORMAT_A8B8G8R8_SSCALED_PACK32: VkFormat = 54;
pub const VkFormat_VK_FORMAT_A8B8G8R8_UINT_PACK32: VkFormat = 55;
pub const VkFormat_VK_FORMAT_A8B8G8R8_SINT_PACK32: VkFormat = 56;
pub const VkFormat_VK_FORMAT_A8B8G8R8_SRGB_PACK32: VkFormat = 57;
pub const VkFormat_VK_FORMAT_A2R10G10B10_UNORM_PACK32: VkFormat = 58;
pub const VkFormat_VK_FORMAT_A2R10G10B10_SNORM_PACK32: VkFormat = 59;
pub const VkFormat_VK_FORMAT_A2R10G10B10_USCALED_PACK32: VkFormat = 60;
pub const VkFormat_VK_FORMAT_A2R10G10B10_SSCALED_PACK32: VkFormat = 61;
pub const VkFormat_VK_FORMAT_A2R10G10B10_UINT_PACK32: VkFormat = 62;
pub const VkFormat_VK_FORMAT_A2R10G10B10_SINT_PACK32: VkFormat = 63;
pub const VkFormat_VK_FORMAT_A2B10G10R10_UNORM_PACK32: VkFormat = 64;
pub const VkFormat_VK_FORMAT_A2B10G10R10_SNORM_PACK32: VkFormat = 65;
pub const VkFormat_VK_FORMAT_A2B10G10R10_USCALED_PACK32: VkFormat = 66;
pub const VkFormat_VK_FORMAT_A2B10G10R10_SSCALED_PACK32: VkFormat = 67;
pub const VkFormat_VK_FORMAT_A2B10G10R10_UINT_PACK32: VkFormat = 68;
pub const VkFormat_VK_FORMAT_A2B10G10R10_SINT_PACK32: VkFormat = 69;
pub const VkFormat_VK_FORMAT_R16_UNORM: VkFormat = 70;
pub const VkFormat_VK_FORMAT_R16_SNORM: VkFormat = 71;
pub const VkFormat_VK_FORMAT_R16_USCALED: VkFormat = 72;
pub const VkFormat_VK_FORMAT_R16_SSCALED: VkFormat = 73;
pub const VkFormat_VK_FORMAT_R16_UINT: VkFormat = 74;
pub const VkFormat_VK_FORMAT_R16_SINT: VkFormat = 75;
pub const VkFormat_VK_FORMAT_R16_SFLOAT: VkFormat = 76;
pub const VkFormat_VK_FORMAT_R16G16_UNORM: VkFormat = 77;
pub const VkFormat_VK_FORMAT_R16G16_SNORM: VkFormat = 78;
pub const VkFormat_VK_FORMAT_R16G16_USCALED: VkFormat = 79;
pub const VkFormat_VK_FORMAT_R16G16_SSCALED: VkFormat = 80;
pub const VkFormat_VK_FORMAT_R16G16_UINT: VkFormat = 81;
pub const VkFormat_VK_FORMAT_R16G16_SINT: VkFormat = 82;
pub const VkFormat_VK_FORMAT_R16G16_SFLOAT: VkFormat = 83;
pub const VkFormat_VK_FORMAT_R16G16B16_UNORM: VkFormat = 84;
pub const VkFormat_VK_FORMAT_R16G16B16_SNORM: VkFormat = 85;
pub const VkFormat_VK_FORMAT_R16G16B16_USCALED: VkFormat = 86;
pub const VkFormat_VK_FORMAT_R16G16B16_SSCALED: VkFormat = 87;
pub const VkFormat_VK_FORMAT_R16G16B16_UINT: VkFormat = 88;
pub const VkFormat_VK_FORMAT_R16G16B16_SINT: VkFormat = 89;
pub const VkFormat_VK_FORMAT_R16G16B16_SFLOAT: VkFormat = 90;
pub const VkFormat_VK_FORMAT_R16G16B16A16_UNORM: VkFormat = 91;
pub const VkFormat_VK_FORMAT_R16G16B16A16_SNORM: VkFormat = 92;
pub const VkFormat_VK_FORMAT_R16G16B16A16_USCALED: VkFormat = 93;
pub const VkFormat_VK_FORMAT_R16G16B16A16_SSCALED: VkFormat = 94;
pub const VkFormat_VK_FORMAT_R16G16B16A16_UINT: VkFormat = 95;
pub const VkFormat_VK_FORMAT_R16G16B16A16_SINT: VkFormat = 96;
pub const VkFormat_VK_FORMAT_R16G16B16A16_SFLOAT: VkFormat = 97;
pub const VkFormat_VK_FORMAT_R32_UINT: VkFormat = 98;
pub const VkFormat_VK_FORMAT_R32_SINT: VkFormat = 99;
pub const VkFormat_VK_FORMAT_R32_SFLOAT: VkFormat = 100;
pub const VkFormat_VK_FORMAT_R32G32_UINT: VkFormat = 101;
pub const VkFormat_VK_FORMAT_R32G32_SINT: VkFormat = 102;
pub const VkFormat_VK_FORMAT_R32G32_SFLOAT: VkFormat = 103;
pub const VkFormat_VK_FORMAT_R32G32B32_UINT: VkFormat = 104;
pub const VkFormat_VK_FORMAT_R32G32B32_SINT: VkFormat = 105;
pub const VkFormat_VK_FORMAT_R32G32B32_SFLOAT: VkFormat = 106;
pub const VkFormat_VK_FORMAT_R32G32B32A32_UINT: VkFormat = 107;
pub const VkFormat_VK_FORMAT_R32G32B32A32_SINT: VkFormat = 108;
pub const VkFormat_VK_FORMAT_R32G32B32A32_SFLOAT: VkFormat = 109;
pub const VkFormat_VK_FORMAT_R64_UINT: VkFormat = 110;
pub const VkFormat_VK_FORMAT_R64_SINT: VkFormat = 111;
pub const VkFormat_VK_FORMAT_R64_SFLOAT: VkFormat = 112;
pub const VkFormat_VK_FORMAT_R64G64_UINT: VkFormat = 113;
pub const VkFormat_VK_FORMAT_R64G64_SINT: VkFormat = 114;
pub const VkFormat_VK_FORMAT_R64G64_SFLOAT: VkFormat = 115;
pub const VkFormat_VK_FORMAT_R64G64B64_UINT: VkFormat = 116;
pub const VkFormat_VK_FORMAT_R64G64B64_SINT: VkFormat = 117;
pub const VkFormat_VK_FORMAT_R64G64B64_SFLOAT: VkFormat = 118;
pub const VkFormat_VK_FORMAT_R64G64B64A64_UINT: VkFormat = 119;
pub const VkFormat_VK_FORMAT_R64G64B64A64_SINT: VkFormat = 120;
pub const VkFormat_VK_FORMAT_R64G64B64A64_SFLOAT: VkFormat = 121;
pub const VkFormat_VK_FORMAT_B10G11R11_UFLOAT_PACK32: VkFormat = 122;
pub const VkFormat_VK_FORMAT_E5B9G9R9_UFLOAT_PACK32: VkFormat = 123;
pub const VkFormat_VK_FORMAT_D16_UNORM: VkFormat = 124;
pub const VkFormat_VK_FORMAT_X8_D24_UNORM_PACK32: VkFormat = 125;
pub const VkFormat_VK_FORMAT_D32_SFLOAT: VkFormat = 126;
pub const VkFormat_VK_FORMAT_S8_UINT: VkFormat = 127;
pub const VkFormat_VK_FORMAT_D16_UNORM_S8_UINT: VkFormat = 128;
pub const VkFormat_VK_FORMAT_D24_UNORM_S8_UINT: VkFormat = 129;
pub const VkFormat_VK_FORMAT_D32_SFLOAT_S8_UINT: VkFormat = 130;
pub const VkFormat_VK_FORMAT_BC1_RGB_UNORM_BLOCK: VkFormat = 131;
pub const VkFormat_VK_FORMAT_BC1_RGB_SRGB_BLOCK: VkFormat = 132;
pub const VkFormat_VK_FORMAT_BC1_RGBA_UNORM_BLOCK: VkFormat = 133;
pub const VkFormat_VK_FORMAT_BC1_RGBA_SRGB_BLOCK: VkFormat = 134;
pub const VkFormat_VK_FORMAT_BC2_UNORM_BLOCK: VkFormat = 135;
pub const VkFormat_VK_FORMAT_BC2_SRGB_BLOCK: VkFormat = 136;
pub const VkFormat_VK_FORMAT_BC3_UNORM_BLOCK: VkFormat = 137;
pub const VkFormat_VK_FORMAT_BC3_SRGB_BLOCK: VkFormat = 138;
pub const VkFormat_VK_FORMAT_BC4_UNORM_BLOCK: VkFormat = 139;
pub const VkFormat_VK_FORMAT_BC4_SNORM_BLOCK: VkFormat = 140;
pub const VkFormat_VK_FORMAT_BC5_UNORM_BLOCK: VkFormat = 141;
pub const VkFormat_VK_FORMAT_BC5_SNORM_BLOCK: VkFormat = 142;
pub const VkFormat_VK_FORMAT_BC6H_UFLOAT_BLOCK: VkFormat = 143;
pub const VkFormat_VK_FORMAT_BC6H_SFLOAT_BLOCK: VkFormat = 144;
pub const VkFormat_VK_FORMAT_BC7_UNORM_BLOCK: VkFormat = 145;
pub const VkFormat_VK_FORMAT_BC7_SRGB_BLOCK: VkFormat = 146;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK: VkFormat = 147;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK: VkFormat = 148;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK: VkFormat = 149;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK: VkFormat = 150;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK: VkFormat = 151;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK: VkFormat = 152;
pub const VkFormat_VK_FORMAT_EAC_R11_UNORM_BLOCK: VkFormat = 153;
pub const VkFormat_VK_FORMAT_EAC_R11_SNORM_BLOCK: VkFormat = 154;
pub const VkFormat_VK_FORMAT_EAC_R11G11_UNORM_BLOCK: VkFormat = 155;
pub const VkFormat_VK_FORMAT_EAC_R11G11_SNORM_BLOCK: VkFormat = 156;
pub const VkFormat_VK_FORMAT_ASTC_4x4_UNORM_BLOCK: VkFormat = 157;
pub const VkFormat_VK_FORMAT_ASTC_4x4_SRGB_BLOCK: VkFormat = 158;
pub const VkFormat_VK_FORMAT_ASTC_5x4_UNORM_BLOCK: VkFormat = 159;
pub const VkFormat_VK_FORMAT_ASTC_5x4_SRGB_BLOCK: VkFormat = 160;
pub const VkFormat_VK_FORMAT_ASTC_5x5_UNORM_BLOCK: VkFormat = 161;
pub const VkFormat_VK_FORMAT_ASTC_5x5_SRGB_BLOCK: VkFormat = 162;
pub const VkFormat_VK_FORMAT_ASTC_6x5_UNORM_BLOCK: VkFormat = 163;
pub const VkFormat_VK_FORMAT_ASTC_6x5_SRGB_BLOCK: VkFormat = 164;
pub const VkFormat_VK_FORMAT_ASTC_6x6_UNORM_BLOCK: VkFormat = 165;
pub const VkFormat_VK_FORMAT_ASTC_6x6_SRGB_BLOCK: VkFormat = 166;
pub const VkFormat_VK_FORMAT_ASTC_8x5_UNORM_BLOCK: VkFormat = 167;
pub const VkFormat_VK_FORMAT_ASTC_8x5_SRGB_BLOCK: VkFormat = 168;
pub const VkFormat_VK_FORMAT_ASTC_8x6_UNORM_BLOCK: VkFormat = 169;
pub const VkFormat_VK_FORMAT_ASTC_8x6_SRGB_BLOCK: VkFormat = 170;
pub const VkFormat_VK_FORMAT_ASTC_8x8_UNORM_BLOCK: VkFormat = 171;
pub const VkFormat_VK_FORMAT_ASTC_8x8_SRGB_BLOCK: VkFormat = 172;
pub const VkFormat_VK_FORMAT_ASTC_10x5_UNORM_BLOCK: VkFormat = 173;
pub const VkFormat_VK_FORMAT_ASTC_10x5_SRGB_BLOCK: VkFormat = 174;
pub const VkFormat_VK_FORMAT_ASTC_10x6_UNORM_BLOCK: VkFormat = 175;
pub const VkFormat_VK_FORMAT_ASTC_10x6_SRGB_BLOCK: VkFormat = 176;
pub const VkFormat_VK_FORMAT_ASTC_10x8_UNORM_BLOCK: VkFormat = 177;
pub const VkFormat_VK_FORMAT_ASTC_10x8_SRGB_BLOCK: VkFormat = 178;
pub const VkFormat_VK_FORMAT_ASTC_10x10_UNORM_BLOCK: VkFormat = 179;
pub const VkFormat_VK_FORMAT_ASTC_10x10_SRGB_BLOCK: VkFormat = 180;
pub const VkFormat_VK_FORMAT_ASTC_12x10_UNORM_BLOCK: VkFormat = 181;
pub const VkFormat_VK_FORMAT_ASTC_12x10_SRGB_BLOCK: VkFormat = 182;
pub const VkFormat_VK_FORMAT_ASTC_12x12_UNORM_BLOCK: VkFormat = 183;
pub const VkFormat_VK_FORMAT_ASTC_12x12_SRGB_BLOCK: VkFormat = 184;
pub const VkFormat_VK_FORMAT_G8B8G8R8_422_UNORM: VkFormat = 1000156000;
pub const VkFormat_VK_FORMAT_B8G8R8G8_422_UNORM: VkFormat = 1000156001;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM: VkFormat = 1000156002;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_420_UNORM: VkFormat = 1000156003;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM: VkFormat = 1000156004;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_422_UNORM: VkFormat = 1000156005;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM: VkFormat = 1000156006;
pub const VkFormat_VK_FORMAT_R10X6_UNORM_PACK16: VkFormat = 1000156007;
pub const VkFormat_VK_FORMAT_R10X6G10X6_UNORM_2PACK16: VkFormat = 1000156008;
pub const VkFormat_VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16: VkFormat = 1000156009;
pub const VkFormat_VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: VkFormat = 1000156010;
pub const VkFormat_VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: VkFormat = 1000156011;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: VkFormat = 1000156012;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16: VkFormat = 1000156013;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: VkFormat = 1000156014;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16: VkFormat = 1000156015;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: VkFormat = 1000156016;
pub const VkFormat_VK_FORMAT_R12X4_UNORM_PACK16: VkFormat = 1000156017;
pub const VkFormat_VK_FORMAT_R12X4G12X4_UNORM_2PACK16: VkFormat = 1000156018;
pub const VkFormat_VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16: VkFormat = 1000156019;
pub const VkFormat_VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: VkFormat = 1000156020;
pub const VkFormat_VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: VkFormat = 1000156021;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: VkFormat = 1000156022;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16: VkFormat = 1000156023;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: VkFormat = 1000156024;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16: VkFormat = 1000156025;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: VkFormat = 1000156026;
pub const VkFormat_VK_FORMAT_G16B16G16R16_422_UNORM: VkFormat = 1000156027;
pub const VkFormat_VK_FORMAT_B16G16R16G16_422_UNORM: VkFormat = 1000156028;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM: VkFormat = 1000156029;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_420_UNORM: VkFormat = 1000156030;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM: VkFormat = 1000156031;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_422_UNORM: VkFormat = 1000156032;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM: VkFormat = 1000156033;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_444_UNORM: VkFormat = 1000330000;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16: VkFormat = 1000330001;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16: VkFormat = 1000330002;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_444_UNORM: VkFormat = 1000330003;
pub const VkFormat_VK_FORMAT_A4R4G4B4_UNORM_PACK16: VkFormat = 1000340000;
pub const VkFormat_VK_FORMAT_A4B4G4R4_UNORM_PACK16: VkFormat = 1000340001;
pub const VkFormat_VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK: VkFormat = 1000066000;
pub const VkFormat_VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK: VkFormat = 1000066001;
pub const VkFormat_VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK: VkFormat = 1000066002;
pub const VkFormat_VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK: VkFormat = 1000066003;
pub const VkFormat_VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK: VkFormat = 1000066004;
pub const VkFormat_VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK: VkFormat = 1000066005;
pub const VkFormat_VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK: VkFormat = 1000066006;
pub const VkFormat_VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK: VkFormat = 1000066007;
pub const VkFormat_VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK: VkFormat = 1000066008;
pub const VkFormat_VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK: VkFormat = 1000066009;
pub const VkFormat_VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK: VkFormat = 1000066010;
pub const VkFormat_VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK: VkFormat = 1000066011;
pub const VkFormat_VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK: VkFormat = 1000066012;
pub const VkFormat_VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK: VkFormat = 1000066013;
pub const VkFormat_VK_FORMAT_A1B5G5R5_UNORM_PACK16: VkFormat = 1000470000;
pub const VkFormat_VK_FORMAT_A8_UNORM: VkFormat = 1000470001;
pub const VkFormat_VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG: VkFormat = 1000054000;
pub const VkFormat_VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG: VkFormat = 1000054001;
pub const VkFormat_VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG: VkFormat = 1000054002;
pub const VkFormat_VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG: VkFormat = 1000054003;
pub const VkFormat_VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG: VkFormat = 1000054004;
pub const VkFormat_VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG: VkFormat = 1000054005;
pub const VkFormat_VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG: VkFormat = 1000054006;
pub const VkFormat_VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG: VkFormat = 1000054007;
pub const VkFormat_VK_FORMAT_R16G16_SFIXED5_NV: VkFormat = 1000464000;
pub const VkFormat_VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT: VkFormat = 1000066000;
pub const VkFormat_VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT: VkFormat = 1000066001;
pub const VkFormat_VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066002;
pub const VkFormat_VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066003;
pub const VkFormat_VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT: VkFormat = 1000066004;
pub const VkFormat_VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066005;
pub const VkFormat_VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT: VkFormat = 1000066006;
pub const VkFormat_VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT: VkFormat = 1000066007;
pub const VkFormat_VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066008;
pub const VkFormat_VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT: VkFormat = 1000066009;
pub const VkFormat_VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT: VkFormat = 1000066010;
pub const VkFormat_VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT: VkFormat = 1000066011;
pub const VkFormat_VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT: VkFormat = 1000066012;
pub const VkFormat_VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT: VkFormat = 1000066013;
pub const VkFormat_VK_FORMAT_G8B8G8R8_422_UNORM_KHR: VkFormat = 1000156000;
pub const VkFormat_VK_FORMAT_B8G8R8G8_422_UNORM_KHR: VkFormat = 1000156001;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR: VkFormat = 1000156002;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR: VkFormat = 1000156003;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR: VkFormat = 1000156004;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR: VkFormat = 1000156005;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR: VkFormat = 1000156006;
pub const VkFormat_VK_FORMAT_R10X6_UNORM_PACK16_KHR: VkFormat = 1000156007;
pub const VkFormat_VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR: VkFormat = 1000156008;
pub const VkFormat_VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR: VkFormat = 1000156009;
pub const VkFormat_VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR: VkFormat = 1000156010;
pub const VkFormat_VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR: VkFormat = 1000156011;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156012;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156013;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156014;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156015;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR: VkFormat = 1000156016;
pub const VkFormat_VK_FORMAT_R12X4_UNORM_PACK16_KHR: VkFormat = 1000156017;
pub const VkFormat_VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR: VkFormat = 1000156018;
pub const VkFormat_VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR: VkFormat = 1000156019;
pub const VkFormat_VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR: VkFormat = 1000156020;
pub const VkFormat_VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR: VkFormat = 1000156021;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156022;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156023;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156024;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156025;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR: VkFormat = 1000156026;
pub const VkFormat_VK_FORMAT_G16B16G16R16_422_UNORM_KHR: VkFormat = 1000156027;
pub const VkFormat_VK_FORMAT_B16G16R16G16_422_UNORM_KHR: VkFormat = 1000156028;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR: VkFormat = 1000156029;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR: VkFormat = 1000156030;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR: VkFormat = 1000156031;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR: VkFormat = 1000156032;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR: VkFormat = 1000156033;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT: VkFormat = 1000330000;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT: VkFormat = 1000330001;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT: VkFormat = 1000330002;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT: VkFormat = 1000330003;
pub const VkFormat_VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT: VkFormat = 1000340000;
pub const VkFormat_VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT: VkFormat = 1000340001;
pub const VkFormat_VK_FORMAT_R16G16_S10_5_NV: VkFormat = 1000464000;
pub const VkFormat_VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR: VkFormat = 1000470000;
pub const VkFormat_VK_FORMAT_A8_UNORM_KHR: VkFormat = 1000470001;
pub const VkFormat_VK_FORMAT_MAX_ENUM: VkFormat = 2147483647;
pub type VkFormat = ::std::os::raw::c_uint;
pub type PFN_vkVoidFunction = ::std::option::Option<unsafe extern "C" fn()>;
pub type PFN_vkGetDeviceProcAddr = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pName: *const ::std::os::raw::c_char,
    ) -> PFN_vkVoidFunction,
>;
extern "C" {
    #[doc = " Query how much memory is required for the Vulkan backend's scratch buffer.\n\n @returns\n The size (in bytes) of the required scratch memory buffer for the VK\n backend."]
    pub fn ffxFsr2GetScratchMemorySizeVK(physicalDevice: VkPhysicalDevice) -> usize;
}
extern "C" {
    #[doc = " Populate an interface with pointers for the VK backend.\n\n @param [out] fsr2Interface              A pointer to a\n <c><i>FfxFsr2Interface</i></c> structure to populate with pointers.\n @param [in] device                      A Vulkan device.\n @param [in] scratchBuffer               A pointer to a buffer of memory\n which can be used by the DirectX(R)12 backend.\n @param [in] scratchBufferSize           The size (in bytes) of the buffer\n pointed to by <c><i>scratchBuffer</i></c>.\n @param [in] physicalDevice              The Vulkan physical device that\n FSR 2.0 will be executed on.\n @param [in] getDeviceProcAddr           A function pointer to\n vkGetDeviceProcAddr which is used to obtain all the other Vulkan functions.\n\n @retval\n FFX_OK                                  The operation completed\n successfully.\n @retval\n FFX_ERROR_CODE_INVALID_POINTER          The <c><i>interface</i></c> pointer\n was <c><i>NULL</i></c>.\n\n @ingroup FSR2 VK"]
    pub fn ffxFsr2GetInterfaceVK(
        outInterface: *mut FfxFsr2Interface,
        scratchBuffer: *mut ::std::os::raw::c_void,
        scratchBufferSize: usize,
        physicalDevice: VkPhysicalDevice,
        getDeviceProcAddr: PFN_vkGetDeviceProcAddr,
    ) -> FfxErrorCode;
}
extern "C" {
    #[doc = " Create a <c><i>FfxFsr2Device</i></c> from a <c><i>VkDevice</i></c>.\n\n @param [in] device                      A pointer to the Vulkan logical\n device.\n\n @returns\n An abstract FidelityFX device.\n\n @ingroup FSR2 VK"]
    pub fn ffxGetDeviceVK(device: VkDevice) -> FfxDevice;
}
extern "C" {
    #[doc = " Create a <c><i>FfxCommandList</i></c> from a <c><i>VkCommandBuffer</i></c>.\n\n @param [in] cmdBuf                      A pointer to the Vulkan command\n buffer.\n\n @returns\n An abstract FidelityFX command list.\n\n @ingroup FSR2 VK"]
    pub fn ffxGetCommandListVK(cmdBuf: VkCommandBuffer) -> FfxCommandList;
}
extern "C" {
    #[doc = " Create a <c><i>FfxResource</i></c> from a <c><i>VkImage</i></c>.\n\n @param [in] context                     A pointer to a\n <c><i>FfxFsr2Context</i></c> structure.\n @param [in] imgVk                       A Vulkan image resource.\n @param [in] imageView                   An image view of the given image\n resource.\n @param [in] width                       The width of the image resource.\n @param [in] height                      The height of the image resource.\n @param [in] imgFormat                   The format of the image resource.\n @param [in] name                        (optional) A name string to identify\n the resource in debug mode.\n @param [in] state                       The state the resource is currently\n in.\n\n @returns\n An abstract FidelityFX resources.\n\n @ingroup FSR2 VK"]
    pub fn ffxGetTextureResourceVK(
        context: *mut FfxFsr2Context,
        imgVk: VkImage,
        imageView: VkImageView,
        width: u32,
        height: u32,
        imgFormat: VkFormat,
        name: *const wchar_t,
        state: FfxResourceStates,
    ) -> FfxResource;
}
extern "C" {
    #[doc = " Create a <c><i>FfxResource</i></c> from a <c><i>VkBuffer</i></c>.\n\n @param [in] context                     A pointer to a\n <c><i>FfxFsr2Context</i></c> structure.\n @param [in] bufVk                       A Vulkan buffer resource.\n @param [in] size                        The size of the buffer resource.\n @param [in] name                        (optional) A name string to identify\n the resource in debug mode.\n @param [in] state                       The state the resource is currently\n in.\n\n @returns\n An abstract FidelityFX resources.\n\n @ingroup FSR2 VK"]
    pub fn ffxGetBufferResourceVK(
        context: *mut FfxFsr2Context,
        bufVk: VkBuffer,
        size: u32,
        name: *const wchar_t,
        state: FfxResourceStates,
    ) -> FfxResource;
}
extern "C" {
    #[doc = " Convert a <c><i>FfxResource</i></c> value to a <c><i>VkImage</i></c>.\n\n @param [in] context                     A pointer to a\n <c><i>FfxFsr2Context</i></c> structure.\n @param [in] resId                       A resourceID.\n\n @returns\n A <c><i>VkImage</i></c>.\n\n @ingroup FSR2 VK"]
    pub fn ffxGetVkImage(context: *mut FfxFsr2Context, resId: u32) -> VkImage;
}
extern "C" {
    #[doc = " Convert a <c><i>FfxResource</i></c> value to a <c><i>VkImageView</i></c>.\n\n @param [in] context                     A pointer to a\n <c><i>FfxFsr2Context</i></c> structure.\n @param [in] resId                       A resourceID.\n\n @returns\n A <c><i>VkImage</i></c>.\n\n @ingroup FSR2 VK"]
    pub fn ffxGetVkImageView(context: *mut FfxFsr2Context, resId: u32) -> VkImageView;
}
extern "C" {
    #[doc = " Convert a <c><i>FfxResource</i></c> value to a <c><i>VkImageLayout</i></c>.\n\n @param [in] context                     A pointer to a\n <c><i>FfxFsr2Context</i></c> structure.\n @param [in] resId                       A resourceID.\n\n @returns\n A <c><i>VkImage</i></c>.\n\n @ingroup FSR2 VK"]
    pub fn ffxGetVkImageLayout(context: *mut FfxFsr2Context, resId: u32) -> VkImageLayout;
}
